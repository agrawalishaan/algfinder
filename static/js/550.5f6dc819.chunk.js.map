{"version":3,"file":"static/js/550.5f6dc819.chunk.js","mappings":"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C,KAAM,KAAM,KAAM,KAAM,KAAM,MAClCoJ,EAAG,CAAC,KAAM,KAAM,KAAM,OAExB,EAAG,CACDoG,EAAG,CAAC,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OACrDxP,EAAG,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MACtEoJ,EAAG,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,OAEpC,EAAG,CACDoG,EAAG,CAAC,SAAU,OAAQ,SAAU,UAAW,QAAS,SACpDxP,EAAG,CACD,KACA,MACA,KACA,MACA,MACA,KACA,MACA,KACA,KACA,MACA,OACA,QAEFoJ,EAAG,CAAC,MAAO,KAAM,KAAM,MAAO,KAAM,MAAO,KAAM,QAEnD,GAAI,CACFoG,EAAG,CACD,OACA,OACA,OACA,QACA,OACA,SACA,SACA,SACA,SACA,SACA,QACA,QACA,SACA,QACA,QACA,QACA,SACA,SACA,SACA,SAEFxP,EAAG,CACD,MACA,KACA,MACA,MACA,KACA,MACA,OACA,OACA,OACA,OACA,OACA,OACA,MACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,MACA,MACA,MACA,MACA,OACA,MACA,OAEFoJ,EAAG,CACD,MACA,MACA,OACA,OACA,OACA,OACA,MACA,MACA,MACA,MACA,OACA,SAGJ,GAAI,CACFoG,EAAG,CACD,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SAEFxP,EAAG,CACD,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MAEFoJ,EAAG,CACD,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,QAwCN,SAAS0Q,GAAYpY,EAAakI,GAEhC,IAAK,IAAIrL,EAAI,EAAGA,EAAImD,EAAElD,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","sources":["../node_modules/cubing/src/cubing/puzzle-geometry/FaceNameSwizzler.ts","../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/NullMapper.ts","../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/FTONotationMapper.ts","../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/FaceRenamingMapper.ts","../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/MegaminxScramblingNotationMapper.ts","../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/NxNxNCubeMapper.ts","../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/PyraminxNotationMapper.ts","../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/SkewbNotationMapper.ts","../node_modules/cubing/src/cubing/puzzle-geometry/Options.ts","../node_modules/cubing/src/cubing/puzzle-geometry/Perm.ts","../node_modules/cubing/src/cubing/puzzle-geometry/PermOriSet.ts","../node_modules/cubing/src/cubing/puzzle-geometry/PGPuzzles.ts","../node_modules/cubing/src/cubing/puzzle-geometry/Quat.ts","../node_modules/cubing/src/cubing/puzzle-geometry/PlatonicGenerator.ts","../node_modules/cubing/src/cubing/puzzle-geometry/SchreierSims.ts","../node_modules/cubing/src/cubing/puzzle-geometry/PuzzleGeometry.ts"],"sourcesContent":["// Manages a set of face names.  Detects whether they are prefix-free.\n// Implements greedy splitting into face names and comparisons between\n// concatenated face names and grip names.\n\nexport class FaceNameSwizzler {\n  public prefixFree: boolean = true;\n  public gripnames: string[] = [];\n  constructor(public facenames: string[], gripnames_arg?: string[]) {\n    if (gripnames_arg) {\n      this.gripnames = gripnames_arg;\n    }\n    for (let i = 0; this.prefixFree && i < facenames.length; i++) {\n      for (let j = 0; this.prefixFree && j < facenames.length; j++) {\n        if (i !== j && facenames[i].startsWith(facenames[j])) {\n          this.prefixFree = false;\n        }\n      }\n    }\n  }\n\n  public setGripNames(names: string[]): void {\n    this.gripnames = names;\n  }\n\n  // split a string into face names and return a list of\n  // indices.\n  public splitByFaceNames(s: string): number[] {\n    const r = [];\n    let at = 0;\n    while (at < s.length) {\n      if (at > 0 && at < s.length && s[at] === \"_\") {\n        at++;\n      }\n      let currentMatch = -1;\n      for (let i = 0; i < this.facenames.length; i++) {\n        if (\n          s.substr(at).startsWith(this.facenames[i]) &&\n          (currentMatch < 0 ||\n            this.facenames[i].length > this.facenames[currentMatch].length)\n        ) {\n          currentMatch = i;\n        }\n      }\n      if (currentMatch >= 0) {\n        r.push(currentMatch);\n        at += this.facenames[currentMatch].length;\n      } else {\n        throw new Error(`Could not split ${s} into face names.`);\n      }\n    }\n    return r;\n  }\n\n  // cons a grip from an array of numbers.\n  public joinByFaceIndices(list: number[]): string {\n    let sep = \"\";\n    const r = [];\n    for (let i = 0; i < list.length; i++) {\n      r.push(sep);\n      r.push(this.facenames[list[i]]);\n      if (!this.prefixFree) {\n        sep = \"_\";\n      }\n    }\n    return r.join(\"\");\n  }\n\n  /*\n   *   Try to match something the user gave us with some geometric\n   *   feature.  We used to have strict requirements:\n   *\n   *      a)  The set of face names are prefix free\n   *      b)  When specifying a corner, all coincident planes were\n   *          specified\n   *\n   *   But, to allow megaminx to have more reasonable and\n   *   conventional names, and to permit shorter canonical\n   *   names, we are relaxing these requirements and adding\n   *   new syntax.  Now:\n   *\n   *      a)  Face names need not be syntax free.\n   *      b)  When parsing a geometric name, we use greedy\n   *          matching, so the longest name that matches the\n   *          user string at the current position is the one\n   *          assumed to match.\n   *      c)  Underscores are permitted to separate face names\n   *          (both in user input and in geometric\n   *          descriptions).\n   *      d)  Default names of corner moves where corners have\n   *          more than three corners, need only include three\n   *          of the corners.\n   *\n   *   This code is not performance-sensitive so we can do it a\n   *   slow and simple way.\n   */\n  public spinmatch(userinput: string, longname: string): boolean {\n    // are these the same rotationally?\n    if (userinput === longname) {\n      return true;\n    }\n    try {\n      const e1 = this.splitByFaceNames(userinput);\n      const e2 = this.splitByFaceNames(longname);\n      // All elements of userinput need to be in the longname.\n      // There should be no duplicate elements in the userinput.\n      // if both have length 1 or length 2, the sets must be equal.\n      // if both have length 3 or more, then the first set must be\n      // a subset of the second.  Order doesn't matter.\n      if (e1.length !== e2.length && e1.length < 3) {\n        return false;\n      }\n      for (let i = 0; i < e1.length; i++) {\n        for (let j = 0; j < i; j++) {\n          if (e1[i] === e1[j]) {\n            return false;\n          }\n        }\n        let found = false;\n        for (let j = 0; j < e2.length; j++) {\n          if (e1[i] === e2[j]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          return false;\n        }\n      }\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /* same as above, but permit both to have v's on the end. */\n  public spinmatchv(userinput: string, longname: string): boolean {\n    if (userinput.endsWith(\"v\") && longname.endsWith(\"v\")) {\n      return this.spinmatch(\n        userinput.slice(0, userinput.length - 1),\n        longname.slice(0, longname.length - 1),\n      );\n    } else {\n      return this.spinmatch(userinput, longname);\n    }\n  }\n\n  public unswizzle(s: string): string {\n    if ((s.endsWith(\"v\") || s.endsWith(\"w\")) && s[0] <= \"Z\") {\n      s = s.slice(0, s.length - 1);\n    }\n    const upperCaseGrip = s.toUpperCase();\n    for (let i = 0; i < this.gripnames.length; i++) {\n      const g = this.gripnames[i];\n      if (this.spinmatch(upperCaseGrip, g)) {\n        return g;\n      }\n    }\n    return s;\n  }\n}\n","import type { Move } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class NullMapper implements NotationMapper {\n  public notationToInternal(move: Move): Move | null {\n    return move;\n  }\n\n  public notationToExternal(move: Move): Move | null {\n    return move;\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class FTONotationMapper implements NotationMapper {\n  constructor(private child: NotationMapper, private sw: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (\n      move.family === \"T\" &&\n      move.innerLayer === undefined &&\n      move.outerLayer === undefined\n    ) {\n      return new Move(\n        new QuantumMove(\"FLRv\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    } else {\n      const r = this.child.notationToInternal(move);\n      return r;\n    }\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    let fam = move.family;\n    if (fam.length > 0 && fam[fam.length - 1] === \"v\") {\n      fam = fam.substring(0, fam.length - 1);\n    }\n    if (this.sw.spinmatch(fam, \"FLUR\")) {\n      return new Move(\n        new QuantumMove(\"T\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n    return this.child.notationToExternal(move);\n  }\n}\n","// face renaming mapper.  Accepts two face name remappers.  We\n// work between the two.\n\nimport { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class FaceRenamingMapper implements NotationMapper {\n  constructor(\n    public internalNames: FaceNameSwizzler,\n    public externalNames: FaceNameSwizzler,\n  ) {}\n\n  // TODO:  consider putting a cache in front of this\n  public convertString(\n    grip: string,\n    a: FaceNameSwizzler,\n    b: FaceNameSwizzler,\n  ): string {\n    let suffix = \"\";\n    if ((grip.endsWith(\"v\") || grip.endsWith(\"v\")) && grip <= \"_\") {\n      suffix = grip.slice(grip.length - 1);\n      grip = grip.slice(0, grip.length - 1);\n    }\n    const upper = grip.toUpperCase();\n    let isLowerCase = false;\n    if (grip !== upper) {\n      isLowerCase = true;\n      grip = upper;\n    }\n    grip = b.joinByFaceIndices(a.splitByFaceNames(grip));\n    if (isLowerCase) {\n      grip = grip.toLowerCase();\n    }\n    return grip + suffix;\n  }\n\n  public convert(move: Move, a: FaceNameSwizzler, b: FaceNameSwizzler): Move {\n    const grip = move.family;\n    const ngrip = this.convertString(grip, a, b);\n    if (grip === ngrip) {\n      return move;\n    } else {\n      return new Move(\n        new QuantumMove(ngrip, move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n  }\n\n  public notationToInternal(move: Move): Move {\n    const r = this.convert(move, this.externalNames, this.internalNames);\n    return r;\n  }\n\n  public notationToExternal(move: Move): Move {\n    return this.convert(move, this.internalNames, this.externalNames);\n  }\n}\n","// Sits on top of a (possibly null) notation mapper, and\n\nimport { Move, QuantumMove } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\n// adds R++/R--/D++/D-- notation mapping.\nexport class MegaminxScramblingNotationMapper implements NotationMapper {\n  constructor(private child: NotationMapper) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (move.innerLayer === undefined && move.outerLayer === undefined) {\n      if (Math.abs(move.amount) === 1) {\n        if (move.family === \"R++\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"R--\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), 2 * move.amount);\n        } else if (move.family === \"D++\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D--\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), 2 * move.amount);\n        }\n\n        // TODO: Figure out if `cubing/alg` should parse `R++` to a family of `R++`.\n        if (move.family === \"R_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        }\n      }\n      if (move.family === \"y\") {\n        return new Move(\"Uv\", move.amount);\n      }\n      if (move.family === \"x\" && Math.abs(move.amount) === 2) {\n        return new Move(\"DRRv\", move.amount / 2);\n      }\n    }\n    return this.child.notationToInternal(move);\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    if (move.family === \"DRRv\" && Math.abs(move.amount) === 1) {\n      return new Move(\n        new QuantumMove(\"x\", move.innerLayer, move.outerLayer),\n        move.amount * 2,\n      );\n    }\n    if (move.family === \"DLLv\" && Math.abs(move.amount) === 1) {\n      return new Move(\n        new QuantumMove(\"x\", move.innerLayer, move.outerLayer),\n        -move.amount * 2,\n      );\n    }\n    if (move.family === \"Uv\") {\n      return new Move(\n        new QuantumMove(\"y\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n    if (move.family === \"DDv\") {\n      return new Move(\"y\", -move.amount);\n    }\n    return this.child.notationToExternal(move);\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class NxNxNCubeMapper implements NotationMapper {\n  constructor(public slices: number) {}\n\n  public notationToInternal(move: Move): Move {\n    const grip = move.family;\n    if (!(move.innerLayer || move.outerLayer)) {\n      if (grip === \"x\") {\n        move = new Move(\"Rv\", move.amount);\n      } else if (grip === \"y\") {\n        move = new Move(\"Uv\", move.amount);\n      } else if (grip === \"z\") {\n        move = new Move(\"Fv\", move.amount);\n      }\n      if ((this.slices & 1) === 1) {\n        if (grip === \"E\") {\n          move = new Move(\n            new QuantumMove(\"D\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        } else if (grip === \"M\") {\n          move = new Move(\n            new QuantumMove(\"L\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        } else if (grip === \"S\") {\n          move = new Move(\n            new QuantumMove(\"F\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        }\n      }\n      if (this.slices > 2) {\n        if (grip === \"e\") {\n          move = new Move(\n            new QuantumMove(\"D\", this.slices - 1, 2),\n            move.amount,\n          );\n        } else if (grip === \"m\") {\n          move = new Move(\n            new QuantumMove(\"L\", this.slices - 1, 2),\n            move.amount,\n          );\n        } else if (grip === \"s\") {\n          move = new Move(\n            new QuantumMove(\"F\", this.slices - 1, 2),\n            move.amount,\n          );\n        }\n      }\n    }\n    return move;\n  }\n\n  // do we want to map slice moves to E/M/S instead of 2U/etc.?\n  public notationToExternal(move: Move): Move {\n    const grip = move.family;\n    if (!(move.innerLayer || move.outerLayer)) {\n      if (grip === \"Rv\") {\n        return new Move(\"x\", move.amount);\n      } else if (grip === \"Uv\") {\n        return new Move(\"y\", move.amount);\n      } else if (grip === \"Fv\") {\n        return new Move(\"z\", move.amount);\n      } else if (grip === \"Lv\") {\n        return new Move(\"x\", -move.amount);\n      } else if (grip === \"Dv\") {\n        return new Move(\"y\", -move.amount);\n      } else if (grip === \"Bv\") {\n        return new Move(\"z\", -move.amount);\n      }\n    }\n    return move;\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nconst pyraminxFamilyMap: Record<string, string> = {\n  U: \"frl\",\n  L: \"fld\",\n  R: \"fdr\",\n  B: \"dlr\",\n  u: \"FRL\",\n  l: \"FLD\",\n  r: \"FDR\",\n  b: \"DLR\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\",\n};\nconst tetraminxFamilyMap: Record<string, string> = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\",\n  u: \"frl\",\n  l: \"fld\",\n  r: \"fdr\",\n  b: \"dlr\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\",\n  d: \"d\",\n  f: \"f\",\n  bl: \"l\",\n  br: \"r\",\n};\n\nconst pyraminxFamilyMapWCA: Record<string, string> = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\",\n};\n\nconst pyraminxExternalQuantumY = new QuantumMove(\"y\");\nconst pyraminxInternalQuantumY = new QuantumMove(\"Dv\");\n\nexport class PyraminxNotationMapper implements NotationMapper {\n  protected wcaHack: boolean = false;\n  map: Record<string, string> = pyraminxFamilyMap;\n\n  constructor(private child: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      const newFamilyWCA = pyraminxFamilyMapWCA[move.family];\n      if (newFamilyWCA) {\n        return new Move(\n          new QuantumMove(newFamilyWCA, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    const newFamily = this.map[move.family];\n\n    if (newFamily) {\n      return new Move(\n        new QuantumMove(newFamily, move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    } else if (pyraminxExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxInternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      for (const [external, internal] of Object.entries(pyraminxFamilyMapWCA)) {\n        if (this.child.spinmatch(move.family, internal)) {\n          return new Move(\n            new QuantumMove(external, move.innerLayer, move.outerLayer),\n            move.amount,\n          );\n        }\n      }\n    }\n    for (const [external, internal] of Object.entries(this.map)) {\n      if (this.child.spinmatch(move.family, internal)) {\n        return new Move(\n          new QuantumMove(external, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    if (pyraminxInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxExternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n}\n\nexport class TetraminxNotationMapper extends PyraminxNotationMapper {\n  protected override wcaHack = true;\n\n  constructor(child: FaceNameSwizzler) {\n    super(child);\n    this.map = tetraminxFamilyMap;\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nconst skewbFamilyMap: Record<string, string> = {\n  U: \"UBL\",\n  UL: \"ULF\",\n  F: \"UFR\",\n  UR: \"URB\",\n  B: \"DBL\",\n  D: \"DFR\",\n  L: \"DLF\",\n  R: \"DRB\",\n  Uv: \"UBLv\",\n  ULv: \"ULFv\",\n  Fv: \"UFRv\",\n  URv: \"URBv\",\n  Bv: \"DBLv\",\n  Dv: \"DFRv\",\n  Lv: \"DLFv\",\n  Rv: \"DRBv\",\n};\n\n// TODO: combine using a similar table.\nconst skewbExternalQuantumX = new QuantumMove(\"x\");\nconst skewbInternalQuantumX = new QuantumMove(\"Rv\");\nconst skewbInternalQuantumXPrime = new QuantumMove(\"Lv\");\nconst skewbExternalQuantumY = new QuantumMove(\"y\");\nconst skewbInternalQuantumY = new QuantumMove(\"Uv\");\nconst skewbInternalQuantumYPrime = new QuantumMove(\"Dv\");\nconst skewbExternalQuantumZ = new QuantumMove(\"z\");\nconst skewbInternalQuantumZ = new QuantumMove(\"Fv\");\nconst skewbInternalQuantumZPrime = new QuantumMove(\"Bv\");\n\nexport class SkewbNotationMapper implements NotationMapper {\n  constructor(private child: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (move.innerLayer || move.outerLayer) {\n      return null;\n    }\n    const newFamily = skewbFamilyMap[move.family];\n    if (newFamily) {\n      return new Move(\n        new QuantumMove(newFamily, move.outerLayer, move.innerLayer),\n        move.amount,\n      );\n    }\n    if (skewbExternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumX, move.amount);\n    }\n    if (skewbExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumY, move.amount);\n    }\n    if (skewbExternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumZ, move.amount);\n    }\n    return null;\n    /*\n       *   (1) We are not including x/y/z in Skewb; they aren't WCA notation and\n       *   it's unclear anyone needs them for reconstructions.\n       *\n    } else if (move.family === \"x\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Rv\", move.amount);\n    } else if (move.family === \"y\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Uv\", move.amount);\n    } else if (move.family === \"z\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Fv\", move.amount);\n       */\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    for (const [external, internal] of Object.entries(skewbFamilyMap)) {\n      if (this.child.spinmatchv(move.family, internal)) {\n        return new Move(\n          new QuantumMove(external, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    if (skewbInternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, move.amount);\n    }\n    if (skewbInternalQuantumXPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, -move.amount);\n    }\n    if (skewbInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, move.amount);\n    }\n    if (skewbInternalQuantumYPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, -move.amount);\n    }\n    if (skewbInternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, move.amount);\n    }\n    if (skewbInternalQuantumZPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, -move.amount);\n    }\n    return null;\n    /*\n       *   See (1) above.\n       *\n    if (move.family === \"Rv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"x\", move.amount);\n    } else if (move.family === \"Uv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"y\", move.amount);\n    } else if (move.family === \"Fv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"z\", move.amount);\n       */\n    // } else {\n    //   return null;\n    // }\n  }\n}\n","import { parsePuzzleDescription, PuzzleDescription } from \"./PuzzleGeometry\";\n\nexport function parseOptions(argv: string[]): {\n  puzzleDescription: PuzzleDescription | null;\n  options: PuzzleGeometryOptions;\n} {\n  let argp = 0;\n  const options: PuzzleGeometryOptions = {};\n  while (argp < argv.length && argv[argp][0] === \"-\") {\n    const option = argv[argp++];\n    if (option === \"--rotations\") {\n      options.addRotations = true;\n    } else if (option === \"--allmoves\") {\n      options.allMoves = true;\n    } else if (option === \"--outerblockmoves\") {\n      options.outerBlockMoves = true;\n    } else if (option === \"--vertexmoves\") {\n      options.vertexMoves = true;\n    } else if (option === \"--nocorners\") {\n      options.includeCornerOrbits = false;\n    } else if (option === \"--noedges\") {\n      options.includeEdgeOrbits = false;\n    } else if (option === \"--noorientation\") {\n      options.fixedOrientation = true;\n    } else if (option === \"--nocenters\") {\n      options.includeCenterOrbits = false;\n    } else if (option === \"--omit\") {\n      options.excludeOrbits = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--moves\") {\n      options.moveList = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--optimize\") {\n      options.optimizeOrbits = true;\n    } else if (option === \"--scramble\") {\n      options.scrambleAmount = 100;\n    } else if (option === \"--fixcorner\") {\n      options.fixedPieceType = \"v\";\n    } else if (option === \"--fixedge\") {\n      options.fixedPieceType = \"e\";\n    } else if (option === \"--fixcenter\") {\n      options.fixedPieceType = \"f\";\n    } else if (option === \"--orientcenters\") {\n      options.orientCenters = true;\n    } else if (option === \"--puzzleorientation\") {\n      options.puzzleOrientation = JSON.parse(argv[argp]); // TODO: Validate input.\n      argp++;\n    } else {\n      throw new Error(`Bad option: ${option}`);\n    }\n  }\n  const puzzleDescription = parsePuzzleDescription(argv.slice(argp).join(\" \"));\n  return { puzzleDescription, options };\n}\n\ntype FaceName = string;\ntype OrientationDirection = [number, number, number];\nexport type FaceBasedOrientationDescription = [\n  [FaceName, OrientationDirection],\n  [FaceName, OrientationDirection],\n];\nexport type BaseFaceCount = 4 | 6 | 8 | 12 | 20;\nexport type FaceBasedOrientationDescriptionLookup = Record<\n  BaseFaceCount,\n  FaceBasedOrientationDescription\n>;\n\nfunction asstructured(v: any): any {\n  if (typeof v === \"string\") {\n    return JSON.parse(v);\n  }\n  return v;\n}\nfunction asboolean(v: any): boolean {\n  if (typeof v === \"string\") {\n    if (v === \"false\") {\n      return false;\n    }\n    return true;\n  } else {\n    return v ? true : false;\n  }\n}\n\nexport class PuzzleGeometryFullOptions {\n  verbosity: number = 0; // verbosity (console.log)\n\n  allMoves: boolean = false; // generate all slice moves in ksolve\n  outerBlockMoves: boolean; // generate outer block moves\n  vertexMoves: boolean = false; // generate vertex moves\n  addRotations: boolean = false; // add symmetry information to ksolve output\n  moveList: string[] | null = null; // move list to generate\n\n  fixedOrientation: boolean = false; // eliminate any orientations\n  fixedPieceType: null | \"e\" | \"v\" | \"f\" = null; // fix a piece?\n  orientCenters: boolean = false; // orient centers?\n\n  // TODO: Group these into a single object?\n  includeCornerOrbits: boolean = true; // include corner orbits\n  includeCenterOrbits: boolean = true; // include center orbits\n  includeEdgeOrbits: boolean = true; // include edge orbits\n  // Overrides the previous options.\n  excludeOrbits: string[] = []; // exclude these orbits\n  optimizeOrbits: boolean = false; // optimize PermOri\n\n  grayCorners: boolean = false; // make corner sets gray\n  grayCenters: boolean = false; // make center sets gray\n  grayEdges: boolean = false; // make edge sets gray\n\n  puzzleOrientation: FaceBasedOrientationDescription | null = null; // single puzzle orientation from options\n  puzzleOrientations: FaceBasedOrientationDescriptionLookup | null = null; // puzzle orientation override object from options // TODO: is this needed?\n\n  scrambleAmount: number = 0; // scramble?\n\n  constructor(options: PuzzleGeometryOptions = {}) {\n    Object.assign(this, options);\n  }\n}\n\nexport type PuzzleGeometryOptions = Partial<PuzzleGeometryFullOptions>;\n\nexport function parsePGOptionList(optionlist?: any[]): PuzzleGeometryOptions {\n  const options: PuzzleGeometryOptions = {};\n  if (optionlist !== undefined) {\n    if (optionlist.length % 2 !== 0) {\n      throw new Error(\"Odd length in option list?\");\n    }\n    for (let i = 0; i < optionlist.length; i += 2) {\n      if (optionlist[i] === \"verbose\") {\n        options.verbosity = (options.verbosity ?? 0) + 1;\n      } else if (optionlist[i] === \"quiet\") {\n        options.verbosity = 0;\n      } else if (optionlist[i] === \"allmoves\") {\n        options.allMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"outerblockmoves\") {\n        options.outerBlockMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"vertexmoves\") {\n        options.vertexMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"rotations\") {\n        options.addRotations = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"cornersets\") {\n        options.includeCornerOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"centersets\") {\n        options.includeCenterOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"edgesets\") {\n        options.includeEdgeOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"omit\") {\n        options.excludeOrbits = optionlist[i + 1];\n      } else if (optionlist[i] === \"graycorners\") {\n        options.grayCorners = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"graycenters\") {\n        options.grayCenters = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"grayedges\") {\n        options.grayEdges = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"movelist\") {\n        options.moveList = asstructured(optionlist[i + 1]);\n      } else if (optionlist[i] === \"killorientation\") {\n        options.fixedOrientation = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"optimize\") {\n        options.optimizeOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"scramble\") {\n        options.scrambleAmount = optionlist[i + 1];\n      } else if (optionlist[i] === \"fix\") {\n        options.fixedPieceType = optionlist[i + 1];\n      } else if (optionlist[i] === \"orientcenters\") {\n        options.orientCenters = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"puzzleorientation\") {\n        options.puzzleOrientation = asstructured(optionlist[i + 1]);\n      } else if (optionlist[i] === \"puzzleorientations\") {\n        options.puzzleOrientations = asstructured(optionlist[i + 1]);\n      } else {\n        throw new Error(\n          `Bad option while processing option list ${optionlist[i]}`,\n        );\n      }\n    }\n  }\n  return options;\n}\n","const zeroCache: number[][] = [];\nconst iotaCache: number[][] = [];\n\nexport function zeros(n: number): number[] {\n  if (!zeroCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = 0;\n    }\n    zeroCache[n] = c;\n  }\n  return zeroCache[n];\n}\n\nexport function iota(n: number): number[] {\n  if (!iotaCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = i;\n    }\n    iotaCache[n] = c;\n  }\n  return iotaCache[n];\n}\n\nexport function identity(n: number): Perm {\n  return new Perm(iota(n));\n}\n\nexport function random(n: number): Perm {\n  // random\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = i;\n  }\n  for (let i = 0; i < n; i++) {\n    const j = i + Math.floor((n - i) * Math.random());\n    const t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n  }\n  return new Perm(c);\n}\n\nexport function factorial(a: number): bigint {\n  let r = BigInt(1);\n  while (a > 1) {\n    r *= BigInt(a);\n    a--;\n  }\n  return r;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (a > b) {\n    const t = a;\n    a = b;\n    b = t;\n  }\n  while (a > 0) {\n    const m = b % a;\n    b = a;\n    a = m;\n  }\n  return b;\n}\n\nexport function lcm(a: number, b: number): number {\n  return (a / gcd(a, b)) * b;\n}\n\nexport class Perm {\n  public n: number; // length\n  public p: number[]; // The permutation itself\n  constructor(a: number[]) {\n    this.n = a.length;\n    this.p = a;\n  }\n\n  public toString(): string {\n    // stringify\n    return `Perm[${this.p.join(\" \")}]`;\n  }\n\n  public mul(p2: Perm): Perm {\n    // multiply\n    const c: number[] = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = p2.p[this.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public rmul(p2: Perm): Perm {\n    // multiply the other way\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = this.p[p2.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public inv(): Perm {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[this.p[i]] = i;\n    }\n    return new Perm(c);\n  }\n\n  public compareTo(p2: Perm): number {\n    // comparison\n    for (let i = 0; i < this.n; i++) {\n      if (this.p[i] !== p2.p[i]) {\n        return this.p[i] - p2.p[i];\n      }\n    }\n    return 0;\n  }\n\n  public toGap(): string {\n    const cyc = new Array<string>();\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc = new Array<number>();\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(`(${incyc.join(\",\")})`);\n    }\n    return cyc.join(\"\");\n  }\n\n  public order(): number {\n    let r = 1;\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      let cs = 0;\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        cs++;\n        seen[j] = true;\n      }\n      r = lcm(r, cs);\n    }\n    return r;\n  }\n}\n","import { Move } from \"../alg\";\nimport type { KPuzzleDefinition, KTransformationData } from \"../kpuzzle\"; // TODO\nimport { NullMapper } from \"./notation-mapping\";\nimport type { NotationMapper } from \"./notation-mapping/NotationMapper\";\n/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ import {\n  factorial,\n  iota,\n  lcm,\n  Perm,\n  zeros,\n} from \"./Perm\";\nexport class PGOrbitDef {\n  constructor(public size: number, public mod: number) {}\n  public reassemblySize(): bigint {\n    return factorial(this.size) * BigInt(this.mod) ** BigInt(this.size);\n  }\n}\n\nlet lastGlobalDefinitionCounter = 0;\n\nexport function externalName(\n  mapper: NotationMapper,\n  moveString: string,\n): string {\n  const mv = Move.fromString(moveString);\n  const mv2 = mapper.notationToExternal(mv);\n  if (mv2 === null || mv === mv2) {\n    return moveString;\n  }\n  return mv2.toString();\n}\n\nexport class PGOrbitsDef {\n  constructor(\n    public orbitnames: string[],\n    private orbitdefs: PGOrbitDef[],\n    public solved: VisibleState,\n    public movenames: string[],\n    public moveops: PGTransform[],\n    public isRotation: boolean[],\n    public forcenames: boolean[],\n  ) {}\n\n  public transformToKTransformationData(t: PGTransform): KTransformationData {\n    const mp: { [orbitName: string]: any } = {};\n    for (let j = 0; j < this.orbitnames.length; j++) {\n      mp[this.orbitnames[j]] = t.orbits[j].toKPuzzle();\n    }\n    return mp;\n  }\n\n  public static transformToKTransformationData(\n    orbitnames: string[],\n    t: PGTransform,\n  ): KTransformationData {\n    const mp: { [orbitName: string]: any } = {};\n    for (let j = 0; j < orbitnames.length; j++) {\n      mp[orbitnames[j]] = t.orbits[j].toKPuzzle();\n    }\n    return mp;\n  }\n\n  private describeSet(s: number, r: string[], mapper: NotationMapper): void {\n    const n = this.orbitdefs[s].size;\n    const m = new Array(n);\n    for (let i = 0; i < n; i++) {\n      m[i] = [];\n    }\n    for (let i = 0; i < this.movenames.length; i++) {\n      if (this.isRotation[i]) {\n        continue;\n      }\n      let mvname = this.movenames[i];\n      if (!this.forcenames[i]) {\n        mvname = externalName(mapper, mvname);\n        if (mvname[mvname.length - 1] === \"'\") {\n          mvname = mvname.substring(0, mvname.length - 1);\n        }\n      }\n      const pd = this.moveops[i].orbits[s];\n      for (let j = 0; j < n; j++) {\n        if (pd.perm[j] !== j || pd.ori[j] !== 0) {\n          m[j].push(mvname);\n        }\n      }\n    }\n    for (let j = 0; j < n; j++) {\n      r.push(`# ${j + 1} ${m[j].join(\" \")}`);\n    }\n  }\n\n  public toKsolve(\n    name: string,\n    mapper: NotationMapper = new NullMapper(),\n  ): string[] {\n    const result = [];\n    result.push(`Name ${name}`);\n    result.push(\"\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(\n        `Set ${this.orbitnames[i]} ${this.orbitdefs[i].size} ${this.orbitdefs[i].mod}`,\n      );\n      this.describeSet(i, result, mapper);\n    }\n    result.push(\"\");\n    result.push(\"Solved\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      this.solved.orbits[i].appendDefinition(\n        result,\n        this.orbitnames[i],\n        false,\n        false,\n      );\n    }\n    result.push(\"End\");\n    for (let i = 0; i < this.movenames.length; i++) {\n      result.push(\"\");\n      let name = this.movenames[i];\n      if (!this.forcenames[i]) {\n        name = externalName(mapper, this.movenames[i]);\n      }\n      let doinv = false;\n      if (name[name.length - 1] === \"'\") {\n        doinv = true;\n        name = name.substring(0, name.length - 1);\n      }\n      result.push(`Move ${name}`);\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        if (doinv) {\n          this.moveops[i].orbits[j]\n            .inv()\n            .appendDefinition(result, this.orbitnames[j], true);\n        } else {\n          this.moveops[i].orbits[j].appendDefinition(\n            result,\n            this.orbitnames[j],\n            true,\n          );\n        }\n      }\n      result.push(\"End\");\n    }\n    // extra blank line on end lets us use join(\"\\n\") to terminate all\n    return result;\n  }\n\n  // TODO: return type.\n  public toKPuzzleDefinition(includemoves: boolean): KPuzzleDefinition {\n    const orbits: KPuzzleDefinition[\"orbits\"] = {};\n    const start: KPuzzleDefinition[\"startStateData\"] = {};\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      orbits[this.orbitnames[i]] = {\n        numPieces: this.orbitdefs[i].size,\n        numOrientations: this.orbitdefs[i].mod,\n      };\n      const startTransformation = this.solved.orbits[i].toKPuzzle();\n      start[this.orbitnames[i]] = {\n        pieces: startTransformation.permutation,\n        orientation: startTransformation.orientation,\n      };\n    }\n    const moves: { [moveName: string]: any } = {};\n    if (includemoves) {\n      for (let i = 0; i < this.movenames.length; i++) {\n        moves[this.movenames[i]] = this.transformToKTransformationData(\n          this.moveops[i],\n        );\n      }\n    }\n    return {\n      name: `PG3D #${++lastGlobalDefinitionCounter}`,\n      orbits,\n      startStateData: start,\n      moves,\n    };\n  }\n\n  public optimize(): PGOrbitsDef {\n    const neworbitnames: string[] = [];\n    const neworbitdefs: PGOrbitDef[] = [];\n    const newsolved: PGOrbit[] = [];\n    const newmoveops: PGOrbit[][] = [];\n    for (let j = 0; j < this.moveops.length; j++) {\n      newmoveops.push([]);\n    }\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      const om = this.orbitdefs[i].mod;\n      const n = this.orbitdefs[i].size;\n      const du = new DisjointUnion(n);\n      const changed = new Array<boolean>(this.orbitdefs[i].size);\n      for (let k = 0; k < n; k++) {\n        changed[k] = false;\n      }\n      // don't consider rotations when optimizing, for what to keep\n      // but *do* consider rotations for unions.\n      for (let j = 0; j < this.moveops.length; j++) {\n        for (let k = 0; k < n; k++) {\n          if (\n            this.moveops[j].orbits[i].perm[k] !== k ||\n            this.moveops[j].orbits[i].ori[k] !== 0\n          ) {\n            if (!this.isRotation[j]) {\n              changed[k] = true;\n            }\n            du.union(k, this.moveops[j].orbits[i].perm[k]);\n          }\n        }\n      }\n      let keepori = true;\n      // right now we kill ori only if solved is unique and\n      // if we can kill it completely.  This is not all the optimization\n      // we can perform.\n      if (om > 1) {\n        keepori = false;\n        const duo = new DisjointUnion(this.orbitdefs[i].size * om);\n        for (let j = 0; j < this.moveops.length; j++) {\n          for (let k = 0; k < n; k++) {\n            if (\n              this.moveops[j].orbits[i].perm[k] !== k ||\n              this.moveops[j].orbits[i].ori[k] !== 0\n            ) {\n              for (let o = 0; o < om; o++) {\n                duo.union(\n                  k * om + o,\n                  this.moveops[j].orbits[i].perm[k] * om +\n                    ((o + this.moveops[j].orbits[i].ori[k]) % om),\n                );\n              }\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let o = 1; o < om; o++) {\n            if (duo.find(j * om) === duo.find(j * om + o)) {\n              keepori = true;\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let k = 0; k < j; k++) {\n            if (\n              this.solved.orbits[i].perm[j] === this.solved.orbits[i].perm[k]\n            ) {\n              keepori = true;\n            }\n          }\n        }\n      }\n      // is there just one result set, or more than one?\n      let nontriv = -1;\n      let multiple = false;\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (changed[j]) {\n          const h = du.find(j);\n          if (nontriv < 0) {\n            nontriv = h;\n          } else if (nontriv !== h) {\n            multiple = true;\n          }\n        }\n      }\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (!changed[j]) {\n          continue;\n        }\n        const h = du.find(j);\n        if (h !== j) {\n          continue;\n        }\n        const no: number[] = [];\n        const on: number[] = [];\n        let nv = 0;\n        for (let k = 0; k < this.orbitdefs[i].size; k++) {\n          if (du.find(k) === j) {\n            no[nv] = k;\n            on[k] = nv;\n            nv++;\n          }\n        }\n        if (multiple) {\n          neworbitnames.push(`${this.orbitnames[i]}_p${j}`);\n        } else {\n          neworbitnames.push(this.orbitnames[i]);\n        }\n        if (keepori) {\n          neworbitdefs.push(new PGOrbitDef(nv, this.orbitdefs[i].mod));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv));\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].remap(no, on, nv));\n          }\n        } else {\n          neworbitdefs.push(new PGOrbitDef(nv, 1));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv).killOri());\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(\n              this.moveops[k].orbits[i].remap(no, on, nv).killOri(),\n            );\n          }\n        }\n      }\n    }\n    return new PGOrbitsDef(\n      neworbitnames,\n      neworbitdefs,\n      new VisibleState(newsolved),\n      this.movenames,\n      newmoveops.map((_) => new PGTransform(_)),\n      this.isRotation,\n      this.forcenames,\n    );\n  }\n\n  // replace the solved state with a new scrambled state.\n  public scramble(n: number): void {\n    this.solved = this.solved.mul(this.getScrambleTransformation(n));\n  }\n\n  // generate a new \"random\" position based on an entropy pool\n  // this should be significantly faster and more random than just\n  // doing a large number of random moves, especially on big puzzles.\n  public getScrambleTransformation(n: number): PGTransform {\n    // don't let n be too tiny\n    if (n < 100) {\n      n = 100;\n    }\n    const pool: PGTransform[] = [];\n    for (let i = 0; i < this.moveops.length; i++) {\n      pool[i] = this.moveops[i];\n    }\n    for (let i = 0; i < pool.length; i++) {\n      const j = Math.floor(Math.random() * pool.length);\n      const t = pool[i];\n      pool[i] = pool[j];\n      pool[j] = t;\n    }\n    if (n < pool.length) {\n      n = pool.length;\n    }\n    for (let i = 0; i < n; i++) {\n      const ri = Math.floor(Math.random() * pool.length);\n      const rj = Math.floor(Math.random() * pool.length);\n      const rm = Math.floor(Math.random() * this.moveops.length);\n      pool[ri] = pool[ri].mul(pool[rj]).mul(this.moveops[rm]);\n      if (Math.random() < 0.1) {\n        // break up parity\n        pool[ri] = pool[ri].mul(this.moveops[rm]);\n      }\n    }\n    let s = pool[0];\n    for (let i = 1; i < pool.length; i++) {\n      s = s.mul(pool[i]);\n    }\n    return s;\n  }\n\n  public reassemblySize(): bigint {\n    let n = BigInt(1);\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      n *= this.orbitdefs[i].reassemblySize();\n    }\n    return n;\n  }\n}\n\nexport class PGOrbit {\n  private static kcache: Record<string, number[]>[] = [];\n\n  public static e(n: number, mod: number): PGOrbit {\n    return new PGOrbit(iota(n), zeros(n), mod);\n  }\n\n  constructor(\n    public perm: number[],\n    public ori: number[],\n    public orimod: number,\n  ) {}\n\n  public mul(b: PGOrbit): PGOrbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    if (this.orimod === 1) {\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n      }\n      return new PGOrbit(newPerm, this.ori, this.orimod);\n    } else {\n      const newOri = new Array<number>(n);\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n        newOri[i] = (this.ori[b.perm[i]] + b.ori[i]) % this.orimod;\n      }\n      return new PGOrbit(newPerm, newOri, this.orimod);\n    }\n  }\n\n  public inv(): PGOrbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    const newOri = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[this.perm[i]] = i;\n      newOri[this.perm[i]] = (this.orimod - this.ori[i]) % this.orimod;\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public equal(b: PGOrbit): boolean {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== b.perm[i] || this.ori[i] !== b.ori[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // in-place mutator\n  public killOri(): this {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      this.ori[i] = 0;\n    }\n    this.orimod = 1;\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const o = this.orimod;\n    if (o === 1) {\n      return new Perm(this.perm);\n    }\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n * o);\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < o; j++) {\n        newPerm[i * o + j] = o * this.perm[i] + ((this.ori[i] + j) % o);\n      }\n    }\n    return new Perm(newPerm);\n  }\n\n  // returns tuple of sets of identical pieces in this orbit\n  public identicalPieces(): number[][] {\n    const done: boolean[] = [];\n    const n = this.perm.length;\n    const r: number[][] = [];\n    for (let i = 0; i < n; i++) {\n      const v = this.perm[i];\n      if (done[v] === undefined) {\n        const s: number[] = [i];\n        done[v] = true;\n        for (let j = i + 1; j < n; j++) {\n          if (this.perm[j] === v) {\n            s.push(j);\n          }\n        }\n        r.push(s);\n      }\n    }\n    return r;\n  }\n\n  public order(): number {\n    // can be made more efficient\n    return this.toPerm().order();\n  }\n\n  public isIdentity(): boolean {\n    const n = this.perm.length;\n    if (this.perm === iota(n) && this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== i || this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private zeroOris(): boolean {\n    const n = this.perm.length;\n    if (this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public remap(no: number[], on: number[], nv: number): PGOrbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    for (let i = 0; i < nv; i++) {\n      newPerm[i] = on[this.perm[no[i]]];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public remapVS(no: number[], nv: number): PGOrbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    let nextNew = 0;\n    const reassign = [];\n    for (let i = 0; i < nv; i++) {\n      const ov = this.perm[no[i]];\n      if (reassign[ov] === undefined) {\n        reassign[ov] = nextNew++;\n      }\n      newPerm[i] = reassign[ov];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public appendDefinition(\n    result: string[],\n    name: string,\n    useVS: boolean,\n    concise: boolean = true,\n  ): void {\n    if (concise && this.isIdentity()) {\n      return;\n    }\n    result.push(name);\n    result.push(this.perm.map((_: number) => _ + 1).join(\" \"));\n    if (!this.zeroOris()) {\n      if (useVS) {\n        const newori = new Array<number>(this.ori.length);\n        for (let i = 0; i < newori.length; i++) {\n          newori[this.perm[i]] = this.ori[i];\n        }\n        result.push(newori.join(\" \"));\n      } else {\n        result.push(this.ori.join(\" \"));\n      }\n    }\n  }\n\n  // TODO: return type\n  public toKPuzzle(): Record<string, number[]> {\n    const n = this.perm.length;\n    if (this.isIdentity()) {\n      if (!PGOrbit.kcache[n]) {\n        PGOrbit.kcache[n] = { permutation: iota(n), orientation: zeros(n) };\n      }\n      return PGOrbit.kcache[n];\n    } else {\n      return { permutation: this.perm, orientation: this.ori };\n    }\n  }\n}\nexport class PGTransformBase {\n  constructor(public orbits: PGOrbit[]) {}\n  public internalMul(b: PGTransformBase): PGOrbit[] {\n    const newOrbits: PGOrbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].mul(b.orbits[i]));\n    }\n    return newOrbits;\n  }\n\n  protected internalInv(): PGOrbit[] {\n    const newOrbits: PGOrbit[] = [];\n    for (const orbit of this.orbits) {\n      newOrbits.push(orbit.inv());\n    }\n    return newOrbits;\n  }\n\n  public equal(b: PGTransformBase): boolean {\n    for (let i = 0; i < this.orbits.length; i++) {\n      if (!this.orbits[i].equal(b.orbits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  protected killOri(): this {\n    for (const orbit of this.orbits) {\n      orbit.killOri();\n    }\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const perms = new Array<Perm>();\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const p = orbit.toPerm();\n      perms.push(p);\n      n += p.n;\n    }\n    const newPerm = new Array<number>(n);\n    n = 0;\n    for (const p of perms) {\n      for (let j = 0; j < p.n; j++) {\n        newPerm[n + j] = n + p.p[j];\n      }\n      n += p.n;\n    }\n    return new Perm(newPerm);\n  }\n\n  public identicalPieces(): number[][] {\n    const r: number[][] = [];\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const o = orbit.orimod;\n      const s = orbit.identicalPieces();\n      for (let j = 0; j < s.length; j++) {\n        r.push(s[j].map((_) => _ * o + n));\n      }\n      n += o * orbit.perm.length;\n    }\n    return r;\n  }\n\n  public order(): number {\n    let r = 1;\n    for (const orbit of this.orbits) {\n      r = lcm(r, orbit.order());\n    }\n    return r;\n  }\n}\nexport class PGTransform extends PGTransformBase {\n  constructor(orbits: PGOrbit[]) {\n    super(orbits);\n  }\n\n  public mul(b: PGTransform): PGTransform {\n    return new PGTransform(this.internalMul(b));\n  }\n\n  public mulScalar(n: number): PGTransform {\n    if (n === 0) {\n      return this.e();\n    }\n    let t: PGTransform = this;\n    if (n < 0) {\n      t = t.inv();\n      n = -n;\n    }\n    while ((n & 1) === 0) {\n      t = t.mul(t);\n      n >>= 1;\n    }\n    if (n === 1) {\n      return t;\n    }\n    let s = t;\n    let r = this.e();\n    while (n > 0) {\n      if (n & 1) {\n        r = r.mul(s);\n      }\n      if (n > 1) {\n        s = s.mul(s);\n      }\n      n >>= 1;\n    }\n    return r;\n  }\n\n  public inv(): PGTransform {\n    return new PGTransform(this.internalInv());\n  }\n\n  public e(): PGTransform {\n    return new PGTransform(\n      this.orbits.map((_: PGOrbit) => PGOrbit.e(_.perm.length, _.orimod)),\n    );\n  }\n}\nexport class VisibleState extends PGTransformBase {\n  constructor(orbits: PGOrbit[]) {\n    super(orbits);\n  }\n\n  public mul(b: PGTransform): VisibleState {\n    return new VisibleState(this.internalMul(b));\n  }\n}\n//  Disjoint set union implementation.\nclass DisjointUnion {\n  private heads: number[];\n  constructor(public n: number) {\n    this.heads = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      this.heads[i] = i;\n    }\n  }\n\n  public find(v: number): number {\n    let h = this.heads[v];\n    if (this.heads[h] === h) {\n      return h;\n    }\n    h = this.find(this.heads[h]);\n    this.heads[v] = h;\n    return h;\n  }\n\n  public union(a: number, b: number): void {\n    const ah = this.find(a);\n    const bh = this.find(b);\n    if (ah < bh) {\n      this.heads[bh] = ah;\n    } else if (ah > bh) {\n      this.heads[ah] = bh;\n    }\n  }\n}\nexport function showcanon(g: PGOrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  curlev[0] = 1;\n  for (let d = 0; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (\n          ((st >> mv) & 1) === 0 &&\n          (st & commutes[mv] & ((1 << mv) - 1)) === 0\n        ) {\n          const nst = (st & commutes[mv]) | (1 << mv);\n          if (nextlev[nst] === undefined) {\n            nextlev[nst] = 0;\n          }\n          nextlev[nst] += (orders[mv] - 1) * cnt;\n        }\n      }\n    }\n    disp(`${d}: canonseq ${sum} states ${uniq}`);\n    curlev = nextlev;\n  }\n}\n// This is a less effective canonicalization (that happens to work fine\n// for the 3x3x3).  We include this only for comparison.\nexport function showcanon0(g: PGOrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  disp(\"0: canonseq 1\");\n  for (let x = 0; x < orders.length; x++) {\n    curlev[x] = orders[x] - 1;\n  }\n  for (let d = 1; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (mv === st || (commutes[mv] & (1 << st) && mv < st)) {\n          continue;\n        }\n        if (nextlev[mv] === undefined) {\n          nextlev[mv] = 0;\n        }\n        nextlev[mv] += (orders[mv] - 1) * cnt;\n      }\n    }\n    disp(`${d}\": canonseq ${sum} states ${uniq}`);\n    curlev = nextlev;\n  }\n}\n","export type PuzzleDescriptionString = string;\n\nexport const PGPuzzles: { [name: string]: PuzzleDescriptionString } = {\n  \"2x2x2\": \"c f 0\",\n  \"3x3x3\": \"c f 0.333333333333333\",\n  \"4x4x4\": \"c f 0.5 f 0\",\n  \"5x5x5\": \"c f 0.6 f 0.2\",\n  \"6x6x6\": \"c f 0.666666666666667 f 0.333333333333333 f 0\",\n  \"7x7x7\": \"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143\",\n  \"8x8x8\": \"c f 0.75 f 0.5 f 0.25 f 0\",\n  \"9x9x9\":\n    \"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111\",\n  \"10x10x10\": \"c f 0.8 f 0.6 f 0.4 f 0.2 f 0\",\n  \"11x11x11\":\n    \"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909\",\n  \"12x12x12\":\n    \"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0\",\n  \"13x13x13\":\n    \"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769\",\n  \"20x20x20\": \"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9\",\n  \"30x30x30\":\n    \"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333\",\n  \"40x40x40\":\n    \"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95\",\n  skewb: \"c v 0\",\n  \"master skewb\": \"c v 0.275\",\n  \"professor skewb\": \"c v 0 v 0.38\",\n  \"compy cube\": \"c v 0.915641442663986\",\n  helicopter: \"c e 0.707106781186547\",\n  \"curvy copter\": \"c e 0.83\",\n  dino: \"c v 0.577350269189626\",\n  \"little chop\": \"c e 0\",\n  pyramorphix: \"t e 0\",\n  mastermorphix: \"t e 0.346184634065199\",\n  pyraminx: \"t v 0.333333333333333 v 1.66666666666667\",\n  tetraminx: \"t v 0.333333333333333\",\n  \"master pyraminx\": \"t v 0 v 1 v 2\",\n  \"master tetraminx\": \"t v 0 v 1\",\n  \"professor pyraminx\": \"t v -0.2 v 0.6 v 1.4 v 2.2\",\n  \"professor tetraminx\": \"t v -0.2 v 0.6 v 1.4\",\n  \"Jing pyraminx\": \"t f 0\",\n  \"master pyramorphix\": \"t e 0.866025403784437\",\n  megaminx: \"d f 0.7\",\n  gigaminx: \"d f 0.64 f 0.82\",\n  teraminx: \"d f 0.64 f 0.76 f 0.88\",\n  petaminx: \"d f 0.64 f 0.73 f 0.82 f 0.91\",\n  examinx: \"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928\",\n  zetaminx: \"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94\",\n  yottaminx: \"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486\",\n  pentultimate: \"d f 0\",\n  \"master pentultimate\": \"d f 0.1\",\n  \"elite pentultimate\": \"d f 0 f 0.145905\",\n  // exact value for starminx is sqrt(5(5-2 sqrt(5))/3)\n  starminx: \"d v 0.937962370425399\",\n  \"starminx 2\": \"d f 0.23606797749979\",\n  \"pyraminx crystal\": \"d f 0.447213595499989\",\n  chopasaurus: \"d v 0\",\n  \"big chop\": \"d e 0\",\n  \"skewb diamond\": \"o f 0\",\n  FTO: \"o f 0.333333333333333\",\n  \"master FTO\": \"o f 0.5 f 0\",\n  \"Christopher's jewel\": \"o v 0.577350269189626\",\n  octastar: \"o e 0\",\n  \"Trajber's octahedron\": \"o v 0.433012701892219\",\n  \"radio chop\": \"i f 0\",\n  icosamate: \"i v 0\",\n  \"icosahedron 2\": \"i v 0.18759247376021\",\n  \"icosahedron 3\": \"i v 0.18759247376021 e 0\",\n  \"icosahedron static faces\": \"i v 0.84\",\n  \"icosahedron moving faces\": \"i v 0.73\",\n  \"Eitan's star\": \"i f 0.61803398874989\",\n  \"2x2x2 + dino\": \"c f 0 v 0.577350269189626\",\n  \"2x2x2 + little chop\": \"c f 0 e 0\",\n  \"dino + little chop\": \"c v 0.577350269189626 e 0\",\n  \"2x2x2 + dino + little chop\": \"c f 0 v 0.577350269189626 e 0\",\n  \"megaminx + chopasaurus\": \"d f 0.61803398875 v 0\",\n  \"starminx combo\": \"d f 0.23606797749979 v 0.937962370425399\",\n};\n\nexport type PuzzleName = keyof typeof PGPuzzles;\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n\n// We need a quaternion class.  We use this to represent rotations,\n// planes, and points.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function centermassface(face: Quat[]): Quat {\n  // calculate a center of a face by averaging points\n  let s = new Quat(0, 0, 0, 0);\n  for (let i = 0; i < face.length; i++) {\n    s = s.sum(face[i]);\n  }\n  return s.smul(1.0 / face.length);\n}\n\nexport function solvethreeplanes(\n  p1: number,\n  p2: number,\n  p3: number,\n  planes: Quat[],\n): any {\n  // find intersection of three planes but only if interior\n  // Takes three indices into a plane array, and returns the point at the\n  // intersection of all three, but only if it is internal to all planes.\n  const p = planes[p1].intersect3(planes[p2], planes[p3]);\n  if (!p) {\n    return p;\n  }\n  for (let i = 0; i < planes.length; i++) {\n    if (i !== p1 && i !== p2 && i !== p3) {\n      const dt = planes[i].b * p.b + planes[i].c * p.c + planes[i].d * p.d;\n      if (\n        (planes[i].a > 0 && dt > planes[i].a) ||\n        (planes[i].a < 0 && dt < planes[i].a)\n      ) {\n        return false;\n      }\n    }\n  }\n  return p;\n}\n\nexport class Quat {\n  constructor(\n    public a: number,\n    public b: number,\n    public c: number,\n    public d: number,\n  ) {}\n\n  public mul(q: Quat): Quat {\n    // Quaternion multiplication\n    return new Quat(\n      this.a * q.a - this.b * q.b - this.c * q.c - this.d * q.d,\n      this.a * q.b + this.b * q.a + this.c * q.d - this.d * q.c,\n      this.a * q.c - this.b * q.d + this.c * q.a + this.d * q.b,\n      this.a * q.d + this.b * q.c - this.c * q.b + this.d * q.a,\n    );\n  }\n\n  public toString(): string {\n    return `Q[${this.a},${this.b},${this.c},${this.d}]`;\n  }\n\n  public dist(q: Quat): number {\n    // Euclidean distance\n    return Math.hypot(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public len(): number {\n    // Euclidean length\n    return Math.hypot(this.a, this.b, this.c, this.d);\n  }\n\n  public cross(q: Quat): Quat {\n    // cross product\n    return new Quat(\n      0,\n      this.c * q.d - this.d * q.c,\n      this.d * q.b - this.b * q.d,\n      this.b * q.c - this.c * q.b,\n    );\n  }\n\n  public dot(q: Quat): number {\n    // dot product of two quaternions\n    return this.b * q.b + this.c * q.c + this.d * q.d;\n  }\n\n  public normalize(): Quat {\n    // make the magnitude be 1\n    const d = Math.sqrt(this.dot(this));\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public makenormal(): Quat {\n    // make a normal vector from a plane or quat or point\n    return new Quat(0, this.b, this.c, this.d).normalize();\n  }\n\n  public normalizeplane(): Quat {\n    // normalize a plane\n    const d = Math.hypot(this.b, this.c, this.d);\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public smul(m: number): Quat {\n    // scalar multiplication\n    return new Quat(this.a * m, this.b * m, this.c * m, this.d * m);\n  }\n\n  public sum(q: Quat): Quat {\n    // quaternion sum\n    return new Quat(this.a + q.a, this.b + q.b, this.c + q.c, this.d + q.d);\n  }\n\n  public sub(q: Quat): Quat {\n    // difference\n    return new Quat(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public angle(): number {\n    // quaternion angle\n    return 2 * Math.acos(this.a);\n  }\n\n  public invrot(): Quat {\n    // quaternion inverse rotation\n    return new Quat(this.a, -this.b, -this.c, -this.d);\n  }\n\n  public det3x3(\n    a00: number,\n    a01: number,\n    a02: number,\n    a10: number,\n    a11: number,\n    a12: number,\n    a20: number,\n    a21: number,\n    a22: number,\n  ): number {\n    // 3x3 determinant\n    return (\n      a00 * (a11 * a22 - a12 * a21) +\n      a01 * (a12 * a20 - a10 * a22) +\n      a02 * (a10 * a21 - a11 * a20)\n    );\n  }\n\n  public rotateplane(q: Quat): Quat {\n    // rotate a plane using a quaternion\n    const t = q.mul(new Quat(0, this.b, this.c, this.d)).mul(q.invrot());\n    t.a = this.a;\n    return t;\n  }\n\n  // return any vector orthogonal to the given one.  Find the smallest\n  // component (in absolute value) and return the cross product of that\n  // axis with the given vector.\n  public orthogonal(): Quat {\n    const ab = Math.abs(this.b);\n    const ac = Math.abs(this.c);\n    const ad = Math.abs(this.d);\n    if (ab < ac && ab < ad) {\n      return this.cross(new Quat(0, 1, 0, 0)).normalize();\n    } else if (ac < ab && ac < ad) {\n      return this.cross(new Quat(0, 0, 1, 0)).normalize();\n    } else {\n      return this.cross(new Quat(0, 0, 0, 1)).normalize();\n    }\n  }\n\n  // return the Quaternion that will rotate the this vector\n  // to the b vector through rotatepoint.\n  public pointrotation(b: Quat): Quat {\n    const a = this.normalize();\n    b = b.normalize();\n    if (a.sub(b).len() < eps) {\n      return new Quat(1, 0, 0, 0);\n    }\n    let h = a.sum(b);\n    if (h.len() < eps) {\n      h = h.orthogonal();\n    } else {\n      h = h.normalize();\n    }\n    const r = a.cross(h);\n    r.a = a.dot(h);\n    return r;\n  }\n\n  // given two vectors, return the portion of the first that\n  // is not in the direction of the second.\n  public unproject(b: Quat): Quat {\n    return this.sum(b.smul(-this.dot(b) / (this.len() * b.len())));\n  }\n\n  public rotatepoint(q: Quat): Quat {\n    // rotate a point\n    return q.mul(this).mul(q.invrot());\n  }\n\n  public rotateface(face: Quat[]): Quat[] {\n    // rotate a face by this Q.\n    return face.map((_: Quat) => _.rotatepoint(this));\n  }\n\n  public intersect3(p2: Quat, p3: Quat): Quat | false {\n    // intersect three planes if there is one\n    const det = this.det3x3(\n      this.b,\n      this.c,\n      this.d,\n      p2.b,\n      p2.c,\n      p2.d,\n      p3.b,\n      p3.c,\n      p3.d,\n    );\n    if (Math.abs(det) < eps) {\n      return false; // TODO: Change to `null` or `undefined`?\n    }\n    return new Quat(\n      0,\n      this.det3x3(this.a, this.c, this.d, p2.a, p2.c, p2.d, p3.a, p3.c, p3.d) /\n        det,\n      this.det3x3(this.b, this.a, this.d, p2.b, p2.a, p2.d, p3.b, p3.a, p3.d) /\n        det,\n      this.det3x3(this.b, this.c, this.a, p2.b, p2.c, p2.a, p3.b, p3.c, p3.a) /\n        det,\n    );\n  }\n\n  public side(x: number): number {\n    // is this point close to the origin, or on one or the other side?\n    if (x > eps) {\n      return 1;\n    }\n    if (x < -eps) {\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * Cuts a face by this plane, or returns null if there\n   * is no intersection.\n   * @param face The face to cut.\n   */\n  public cutface(face: Quat[]): Quat[][] | null {\n    const d = this.a;\n    let seen = 0;\n    let r = null;\n    for (let i = 0; i < face.length; i++) {\n      seen |= 1 << (this.side(face[i].dot(this) - d) + 1);\n    }\n    if ((seen & 5) === 5) {\n      r = [];\n      // saw both sides\n      const inout = face.map((_: Quat) => this.side(_.dot(this) - d));\n      for (let s = -1; s <= 1; s += 2) {\n        const nface = [];\n        for (let k = 0; k < face.length; k++) {\n          if (inout[k] === s || inout[k] === 0) {\n            nface.push(face[k]);\n          }\n          const kk = (k + 1) % face.length;\n          if (inout[k] + inout[kk] === 0 && inout[k] !== 0) {\n            const vk = face[k].dot(this) - d;\n            const vkk = face[kk].dot(this) - d;\n            const r = vk / (vk - vkk);\n            const pt = face[k].smul(1 - r).sum(face[kk].smul(r));\n            nface.push(pt);\n          }\n        }\n        r.push(nface);\n      }\n    }\n    return r;\n  }\n\n  public cutfaces(faces: Quat[][]): Quat[][] {\n    // Cut a set of faces by a plane and return new set\n    const nfaces = [];\n    for (let j = 0; j < faces.length; j++) {\n      const face = faces[j];\n      const t = this.cutface(face);\n      if (t) {\n        nfaces.push(t[0]);\n        nfaces.push(t[1]);\n      } else {\n        nfaces.push(face);\n      }\n    }\n    return nfaces;\n  }\n\n  public faceside(face: Quat[]): number {\n    // which side of a plane is a face on?\n    const d = this.a;\n    for (let i = 0; i < face.length; i++) {\n      const s = this.side(face[i].dot(this) - d);\n      if (s !== 0) {\n        return s;\n      }\n    }\n    throw new Error(\"Could not determine side of plane in faceside\");\n  }\n\n  public sameplane(p: Quat): boolean {\n    // are two planes the same?\n    const a = this.normalize();\n    const b = p.normalize();\n    return a.dist(b) < eps || a.dist(b.smul(-1)) < eps;\n  }\n\n  public makecut(r: number): Quat {\n    // make a cut from a normal vector\n    return new Quat(r, this.b, this.c, this.d);\n  }\n}\n","/* tslint:disable prefer-for-of */ // TODO\n\nimport { Quat, solvethreeplanes } from \"./Quat\";\n\n// Next we define a class that yields quaternion generators for each of\n// the five platonic solids.  The quaternion generators chosen are\n// chosen specifically so that the first quaternion doubles as a plane\n// description that yields the given Platonic solid (so for instance, the\n// cubical group and octahedral group are identical in math, but we\n// give distinct representations choosing the first quaternion so that\n// we get the desired figure.)  Our convention is one vertex of the\n// shape points precisely down.\n\n// This class is static.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function cube(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(s5, s5, 0, 0), new Quat(s5, 0, s5, 0)];\n}\n\nexport function tetrahedron(): Quat[] {\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(0.5, 0.5, 0.5, -0.5)];\n}\n\nexport function dodecahedron(): Quat[] {\n  const d36 = (2 * Math.PI) / 10;\n  let dx = 0.5 + 0.3 * Math.sqrt(5);\n  let dy = 0.5 + 0.1 * Math.sqrt(5);\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  return [\n    new Quat(Math.cos(d36), dx * Math.sin(d36), dy * Math.sin(d36), 0),\n    new Quat(0.5, 0.5, 0.5, 0.5),\n  ];\n}\n\nexport function icosahedron(): Quat[] {\n  let dx = 1 / 6 + Math.sqrt(5) / 6;\n  let dy = 2 / 3 + Math.sqrt(5) / 3;\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  const ang = (2 * Math.PI) / 6;\n  return [\n    new Quat(Math.cos(ang), dx * Math.sin(ang), dy * Math.sin(ang), 0),\n    new Quat(Math.cos(ang), -dx * Math.sin(ang), dy * Math.sin(ang), 0),\n  ];\n}\n\nexport function octahedron(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(s5, 0, 0, s5)];\n}\n\nexport function closure(g: Quat[]): Quat[] {\n  // compute the closure of a set of generators\n  // This is quadratic in the result size.  Also, it has no protection\n  // against you providing a bogus set of generators that would generate\n  // an infinite group.\n  const q = [new Quat(1, 0, 0, 0)];\n  for (let i = 0; i < q.length; i++) {\n    for (let j = 0; j < g.length; j++) {\n      const ns = g[j].mul(q[i]);\n      const negns = ns.smul(-1);\n      let wasseen = false;\n      for (let k = 0; k < q.length; k++) {\n        if (ns.dist(q[k]) < eps || negns.dist(q[k]) < eps) {\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        q.push(ns);\n      }\n    }\n  }\n  return q;\n}\n\nexport function uniqueplanes(p: Quat, g: Quat[]): Quat[] {\n  // compute unique plane rotations\n  // given a rotation group and a plane, find the rotations that\n  // generate unique planes.  This is quadratic in the return size.\n  const planes = [];\n  const planerot = [];\n  for (let i = 0; i < g.length; i++) {\n    const p2 = p.rotateplane(g[i]);\n    let wasseen = false;\n    for (let j = 0; j < planes.length; j++) {\n      if (p2.dist(planes[j]) < eps) {\n        wasseen = true;\n        break;\n      }\n    }\n    if (!wasseen) {\n      planes.push(p2);\n      planerot.push(g[i]);\n    }\n  }\n  return planerot;\n}\n\nexport function getface(planes: Quat[]): Quat[] {\n  // compute a face given a set of planes\n  // The face returned will be a set of points that lie in the first plane\n  // in the given array, that are on the surface of the polytope defined\n  // by all the planes, and will be returned in clockwise order.\n  // This is O(planes^2 * return size + return_size^2).\n  const face: Quat[] = [];\n  for (let i = 1; i < planes.length; i++) {\n    for (let j = i + 1; j < planes.length; j++) {\n      const p = solvethreeplanes(0, i, j, planes);\n      if (p) {\n        let wasseen = false;\n        for (let k = 0; k < face.length; k++) {\n          if (p.dist(face[k]) < eps) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          face.push(p);\n        }\n      }\n    }\n  }\n  for (;;) {\n    let changed = false;\n    for (let i = 0; i < face.length; i++) {\n      const j: number = (i + 1) % face.length;\n      if (planes[0].dot(face[i].cross(face[j])) < 0) {\n        const t: Quat = face[i];\n        face[i] = face[j];\n        face[j] = t;\n        changed = true;\n      }\n    }\n    if (!changed) {\n      break;\n    }\n  }\n  return face;\n}\n","import { identity, Perm } from \"./Perm\";\n\nclass FactoredNumber {\n  public mult: number[];\n  constructor() {\n    this.mult = [];\n  }\n\n  public multiply(n: number): void {\n    for (let f = 2; f * f <= n; f++) {\n      while (n % f === 0) {\n        if (undefined !== this.mult[f]) {\n          this.mult[f]++;\n        } else {\n          this.mult[f] = 1;\n        }\n        n /= f;\n      }\n    }\n    if (n > 1) {\n      if (undefined !== this.mult[n]) {\n        this.mult[n]++;\n      } else {\n        this.mult[n] = 1;\n      }\n    }\n  }\n\n  public toString(): string {\n    let r = \"\";\n    for (let i = 0; i < this.mult.length; i++) {\n      if (undefined !== this.mult[i]) {\n        if (r !== \"\") {\n          r += \"*\";\n        }\n        r += i;\n        if (this.mult[i] > 1) {\n          r += `^${this.mult[i]}`;\n        }\n      }\n    }\n    return r;\n  }\n}\n\nexport function schreierSims(g: Perm[], disp: (s: string) => void): bigint {\n  const n = g[0].p.length;\n  const e = identity(n);\n  let sgs: Perm[][] = [];\n  let sgsi: Perm[][] = [];\n  let sgslen: number[][] = [];\n  let Tk: Perm[][] = [];\n  let Tklen: number[][] = [];\n  function resolve(p: Perm): boolean {\n    for (let i = p.p.length - 1; i >= 0; i--) {\n      const j = p.p[i];\n      if (j !== i) {\n        if (!sgs[i][j]) {\n          return false;\n        }\n        p = p.mul(sgsi[i][j]);\n      }\n    }\n    return true;\n  }\n  function knutha(k: number, p: Perm, len: number): void {\n    Tk[k].push(p);\n    Tklen[k].push(len);\n    for (let i = 0; i < sgs[k].length; i++) {\n      if (sgs[k][i]) {\n        knuthb(k, sgs[k][i].mul(p), len + sgslen[k][i]);\n      }\n    }\n  }\n  function knuthb(k: number, p: Perm, len: number): void {\n    const j = p.p[k];\n    if (!sgs[k][j]) {\n      sgs[k][j] = p;\n      sgsi[k][j] = p.inv();\n      sgslen[k][j] = len;\n      for (let i = 0; i < Tk[k].length; i++) {\n        knuthb(k, p.mul(Tk[k][i]), len + Tklen[k][i]);\n      }\n      return;\n    }\n    const p2 = p.mul(sgsi[k][j]);\n    if (!resolve(p2)) {\n      knutha(k - 1, p2, len + sgslen[k][j]);\n    }\n  }\n  function getsgs(): bigint {\n    sgs = [];\n    sgsi = [];\n    Tk = [];\n    sgslen = [];\n    Tklen = [];\n    for (let i = 0; i < n; i++) {\n      sgs.push([]);\n      sgsi.push([]);\n      sgslen.push([]);\n      Tk.push([]);\n      Tklen.push([]);\n      sgs[i][i] = e;\n      sgsi[i][i] = e;\n      sgslen[i][i] = 0;\n    }\n    let none = 0;\n    let sz = BigInt(1);\n    for (let i = 0; i < g.length; i++) {\n      knutha(n - 1, g[i], 1);\n      sz = BigInt(1);\n      let tks = 0;\n      let sollen = 0;\n      const avgs = [];\n      const mults = new FactoredNumber();\n      for (let j = 0; j < n; j++) {\n        let cnt = 0;\n        let lensum = 0;\n        for (let k = 0; k < n; k++) {\n          if (sgs[j][k]) {\n            cnt++;\n            lensum += sgslen[j][k];\n            if (j !== k) {\n              none++;\n            }\n          }\n        }\n        tks += Tk[j].length;\n        sz *= BigInt(cnt);\n        if (cnt > 1) {\n          mults.multiply(cnt);\n        }\n        const avg = lensum / cnt;\n        avgs.push(avg);\n        sollen += avg;\n      }\n      disp(\n        `${i}: sz ${sz} T ${tks} sol ${sollen} none ${none} mults ${mults.toString()}`,\n      );\n    }\n    return sz;\n  }\n  return getsgs();\n}\n","import { Move, QuantumMove } from \"../alg\";\nimport type { KPuzzleDefinition, KTransformationData } from \"../kpuzzle\";\nimport { FaceNameSwizzler } from \"./FaceNameSwizzler\";\nimport {\n  FaceRenamingMapper,\n  FTONotationMapper,\n  MegaminxScramblingNotationMapper,\n  NotationMapper,\n  NullMapper,\n  NxNxNCubeMapper,\n  PyraminxNotationMapper,\n  SkewbNotationMapper,\n  TetraminxNotationMapper,\n} from \"./notation-mapping\";\nimport {\n  BaseFaceCount,\n  FaceBasedOrientationDescription,\n  FaceBasedOrientationDescriptionLookup,\n  PuzzleGeometryFullOptions,\n  PuzzleGeometryOptions,\n} from \"./Options\";\nimport { iota, Perm, zeros } from \"./Perm\";\nimport {\n  externalName,\n  PGOrbit,\n  PGOrbitDef,\n  PGOrbitsDef,\n  PGTransform,\n  showcanon,\n  VisibleState,\n} from \"./PermOriSet\";\nimport { PGPuzzles, PuzzleDescriptionString, PuzzleName } from \"./PGPuzzles\";\nimport {\n  closure,\n  cube,\n  dodecahedron,\n  getface,\n  icosahedron,\n  octahedron,\n  tetrahedron,\n  uniqueplanes,\n} from \"./PlatonicGenerator\";\nimport { centermassface, Quat } from \"./Quat\";\nimport { schreierSims } from \"./SchreierSims\";\n\nexport interface TextureMapper {\n  getuv(fn: number, threed: number[]): number[];\n}\n\nexport interface StickerDatSticker {\n  coords: number[];\n  color: string;\n  orbit: string;\n  ord: number;\n  ori: number;\n  face: number;\n  isDup?: boolean;\n}\n\nexport interface StickerDatFace {\n  coords: number[];\n  name: string;\n}\n\nexport type StickerDatAxis = {\n  coordinates: number[];\n  quantumMove: Move;\n  order: number;\n};\n\nexport interface StickerDat {\n  stickers: StickerDatSticker[];\n  faces: StickerDatFace[];\n  axis: StickerDatAxis[];\n  unswizzle(mv: Move): Move | null;\n  notationMapper: NotationMapper;\n  textureMapper: TextureMapper;\n}\n\n// you can fill these in to help with timing if you want\nfunction tstart(s: string): string {\n  return s;\n}\n\nfunction tend(_: string): void {}\n\nclass Face {\n  private coords: number[];\n  public length: number;\n  constructor(q: Quat[]) {\n    this.coords = new Array(q.length * 3);\n    for (let i = 0; i < q.length; i++) {\n      this.coords[3 * i] = q[i].b;\n      this.coords[3 * i + 1] = q[i].c;\n      this.coords[3 * i + 2] = q[i].d;\n    }\n    this.length = q.length;\n  }\n\n  get(off: number): Quat {\n    return new Quat(\n      0,\n      this.coords[3 * off],\n      this.coords[3 * off + 1],\n      this.coords[3 * off + 2],\n    );\n  }\n\n  centermass(): Quat {\n    let sx = 0;\n    let sy = 0;\n    let sz = 0;\n    for (let i = 0; i < this.length; i++) {\n      sx += this.coords[3 * i];\n      sy += this.coords[3 * i + 1];\n      sz += this.coords[3 * i + 2];\n    }\n    return new Quat(0, sx / this.length, sy / this.length, sz / this.length);\n  }\n\n  rotate(q: Quat): Face {\n    const a = [];\n    for (let i = 0; i < this.length; i++) {\n      a.push(this.get(i).rotatepoint(q));\n    }\n    return new Face(a);\n  }\n\n  rotateforward(): Face {\n    const a = [];\n    for (let i = 1; i < this.length; i++) {\n      a.push(this.get(i));\n    }\n    a.push(this.get(0));\n    return new Face(a);\n  }\n}\n\nexport class FaceTree {\n  constructor(\n    private face: Quat[],\n    private left?: FaceTree,\n    private right?: FaceTree,\n  ) {}\n\n  public split(q: Quat): FaceTree {\n    const t = q.cutface(this.face);\n    if (t !== null) {\n      if (this.left === undefined) {\n        this.left = new FaceTree(t[0]);\n        this.right = new FaceTree(t[1]);\n      } else {\n        this.left = this.left?.split(q);\n        this.right = this.right?.split(q);\n      }\n    }\n    return this;\n  }\n\n  public collect(arr: Face[], leftfirst: boolean): Face[] {\n    if (this.left === undefined) {\n      arr.push(new Face(this.face));\n    } else if (leftfirst) {\n      this.left?.collect(arr, false);\n      this.right?.collect(arr, true);\n    } else {\n      this.right?.collect(arr, false);\n      this.left?.collect(arr, true);\n    }\n    return arr;\n  }\n}\n\nexport function expandfaces(rots: Quat[], faces: Face[]): Face[] {\n  // given a set of faces, expand by rotation set\n  const nfaces = [];\n  for (const rot of rots) {\n    for (const face of faces) {\n      nfaces.push(face.rotate(rot));\n    }\n  }\n  return nfaces;\n}\n\n//  Now we have a geometry class that does the 3D goemetry to calculate\n//  individual sticker information from a Platonic solid and a set of\n//  cuts.  The cuts must have the same symmetry as the Platonic solid;\n//  we even restrict them further to be either vertex-normal,\n//  edge-normal, or face-parallel cuts.  Right now our constructor takes\n//  a character solid indicator (one of c(ube), o(ctahedron), i(cosahedron),\n//  t(etradron), or d(odecahedron), followed by an array of cuts.\n//  Each cut is a character normal indicator that is either f(ace),\n//  e(dge), or v(ertex), followed by a floating point value that gives\n//  the depth of the cut where 0 is the center and 1 is the outside\n//  border of the shape in that direction.\n\n//  This is a heavyweight class with lots of members and construction\n//  is slow.  Be gentle.\n\n//  Everything except a very few methods should be considered private.\n\nconst eps: number = 1e-9;\nconst copyright = \"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\";\nconst permissivieMoveParsing = false;\n\n// This is a description of the nets and the external names we give each\n// face.  The names should be a set of prefix-free upper-case alphabetics\n// so\n// we can easily also name and distinguish vertices and edges, but we\n// may change this in the future.  The nets consist of a list of lists.\n// Each list gives the name of a face, and then the names of the\n// faces connected to that face (in the net) in clockwise order.\n// The length of each list should be one more than the number of\n// edges in the regular polygon for that face.  All polygons must\n// have the same number of edges.\n// The first two faces in the first list must describe a horizontal edge\n// that is at the bottom of a regular polygon.  The first two faces in\n// every subsequent list for a given polytope must describe a edge that\n// is directly connected in the net and has already been described (this\n// sets the location and orientation of the polygon for that face.\n// Any edge that is not directly connected in the net should be given\n// the empty string as the other face.  All faces do not need to have\n// a list starting with that face; just enough to describe the full\n// connectivity of the net.\n//\n// TODO: change this back to a const JSON definition.\nfunction defaultnets(): any {\n  return {\n    // four faces: tetrahedron\n    4: [[\"F\", \"D\", \"L\", \"R\"]],\n    // six faces: cube\n    6: [\n      [\"F\", \"D\", \"L\", \"U\", \"R\"],\n      [\"R\", \"F\", \"\", \"B\", \"\"],\n    ],\n    // eight faces: octahedron\n    8: [\n      [\"F\", \"D\", \"L\", \"R\"],\n      [\"D\", \"F\", \"BR\", \"\"],\n      [\"BR\", \"D\", \"\", \"BB\"],\n      [\"BB\", \"BR\", \"U\", \"BL\"],\n    ],\n    // twelve faces:  dodecahedron; U/F/R/F/BL/BR from megaminx\n    12: [\n      [\"U\", \"FF\", \"\", \"\", \"\", \"\"],\n      [\"FF\", \"U\", \"R\", \"FR\", \"FL\", \"L\"],\n      [\"R\", \"FF\", \"\", \"\", \"DR\", \"\"],\n      [\"DR\", \"R\", \"\", \"BB\", \"\", \"\"],\n      [\"BB\", \"DR\", \"BR\", \"BL\", \"DL\", \"DD\"],\n    ],\n    // twenty faces: icosahedron\n    20: [\n      [\"R\", \"C\", \"F\", \"E\"],\n      [\"F\", \"R\", \"L\", \"U\"],\n      [\"L\", \"F\", \"A\", \"\"],\n      [\"E\", \"R\", \"G\", \"I\"],\n      [\"I\", \"E\", \"S\", \"H\"],\n      [\"S\", \"I\", \"J\", \"B\"],\n      [\"B\", \"S\", \"K\", \"D\"],\n      [\"K\", \"B\", \"M\", \"O\"],\n      [\"O\", \"K\", \"P\", \"N\"],\n      [\"P\", \"O\", \"Q\", \"\"],\n    ],\n  };\n}\n\nenum PGColors {\n  White = \"#ffffff\",\n  Orange = \"#ff8000\",\n  Green = \"#44ee00\",\n  Red = \"#ff0000\",\n  Blue = \"#2266ff\",\n  Yellow = \"#ffff00\",\n\n  Purple = \"#8800dd\",\n  Gray = \"#aaaaaa\",\n  Cream = \"#ffffd0\",\n  Pink = \"#ff66cc\",\n\n  DarkBlue = \"#0000ff\",\n  LightBlue = \"#3399ff\",\n  DarkGreen = \"#008800\",\n  LightGreen = \"#99ff00\",\n}\n\n// TODO: change this back to a const JSON definition.\nfunction defaultcolors(): any {\n  return {\n    // the colors should use the same naming convention as the nets, above.\n    4: {\n      F: PGColors.Green,\n      D: PGColors.Yellow,\n      L: PGColors.Red,\n      R: PGColors.Blue,\n    },\n    6: {\n      U: PGColors.White,\n      F: PGColors.Green,\n      R: PGColors.Red,\n      D: PGColors.Yellow,\n      B: PGColors.Blue,\n      L: PGColors.Orange,\n    },\n    8: {\n      U: PGColors.White,\n      F: PGColors.Red,\n      R: PGColors.Green,\n      D: PGColors.Yellow,\n      BB: PGColors.Blue,\n      L: PGColors.Purple,\n      BL: PGColors.Orange,\n      BR: PGColors.Gray,\n    },\n    12: {\n      U: PGColors.White,\n      FF: PGColors.DarkGreen,\n      R: PGColors.Red,\n      FR: PGColors.Cream,\n      FL: PGColors.LightBlue,\n      L: PGColors.Purple,\n      DR: PGColors.Pink,\n      BB: PGColors.LightGreen,\n      BR: PGColors.DarkBlue,\n      BL: PGColors.Yellow,\n      DL: PGColors.Orange,\n      DD: PGColors.Gray,\n    },\n    20: {\n      R: \"#db69f0\",\n      C: \"#178fde\",\n      F: \"#23238b\",\n      E: \"#9cc726\",\n      L: \"#2c212d\",\n      U: \"#177fa7\",\n      A: \"#e0de7f\",\n      G: \"#2b57c0\",\n      I: \"#41126b\",\n      S: \"#4b8c28\",\n      H: \"#7c098d\",\n      J: \"#7fe7b4\",\n      B: \"#85fb74\",\n      K: \"#3f4bc3\",\n      D: \"#0ff555\",\n      M: \"#f1c2c8\",\n      O: \"#58d340\",\n      P: \"#c514f2\",\n      N: \"#14494e\",\n      Q: \"#8b1be1\",\n    },\n  };\n}\n\n// Orientation conventions are specified here.  For each of the five platonic\n// solids, by face count, we have three lists of \"cubie names\" consisting of\n// a concatenation of face names.  For vertex (corner) and edge cubies, the\n// first face in the concatenated name is the one that will be marked.\n// For center orientations, the first face specifies which center we are\n// referring to, and the second face specifies the direction of the mark for\n// that face.\n\nconst orientationDefaults = {\n  4: {\n    v: [\"DFR\", \"DLF\", \"DRL\", \"FLR\"],\n    e: [\"FR\", \"LF\", \"DF\", \"DL\", \"RD\", \"RL\"],\n    c: [\"DF\", \"FD\", \"RL\", \"LR\"],\n  },\n  6: {\n    v: [\"URF\", \"UBR\", \"ULB\", \"UFL\", \"DFR\", \"DRB\", \"DBL\", \"DLF\"],\n    e: [\"UF\", \"UR\", \"UB\", \"UL\", \"DF\", \"DR\", \"DB\", \"DL\", \"FR\", \"FL\", \"BR\", \"BL\"],\n    c: [\"UB\", \"LU\", \"FU\", \"RU\", \"BU\", \"DF\"],\n  },\n  8: {\n    v: [\"UBBBRR\", \"URFL\", \"ULBLBB\", \"DBRBBBL\", \"DBLLF\", \"DFRBR\"],\n    e: [\n      \"UL\",\n      \"UBB\",\n      \"UR\",\n      \"BRD\",\n      \"BLD\",\n      \"FD\",\n      \"BRR\",\n      \"FR\",\n      \"FL\",\n      \"BLL\",\n      \"BLBB\",\n      \"BRBB\",\n    ],\n    c: [\"BBU\", \"LU\", \"RU\", \"BRD\", \"FD\", \"BLD\", \"DF\", \"UBB\"],\n  },\n  12: {\n    v: [\n      \"URFF\",\n      \"UFFL\",\n      \"ULBL\",\n      \"UBLBR\",\n      \"UBRR\",\n      \"DDDRBB\",\n      \"DDBBDL\",\n      \"DDDLFL\",\n      \"DDFLFR\",\n      \"DDFRDR\",\n      \"LFLDL\",\n      \"FLLFF\",\n      \"FFFRFL\",\n      \"FRFFR\",\n      \"RDRFR\",\n      \"DRRBR\",\n      \"BRBBDR\",\n      \"BBBRBL\",\n      \"BLDLBB\",\n      \"DLBLL\",\n    ],\n    e: [\n      \"UFF\",\n      \"UR\",\n      \"UBR\",\n      \"UBL\",\n      \"UL\",\n      \"DRR\",\n      \"DRBR\",\n      \"DRBB\",\n      \"DRDD\",\n      \"DRFR\",\n      \"DLBB\",\n      \"DLBL\",\n      \"DLL\",\n      \"DLFL\",\n      \"DLDD\",\n      \"FLFR\",\n      \"FRFF\",\n      \"FFFL\",\n      \"BBBR\",\n      \"BRBL\",\n      \"BLBB\",\n      \"FRDD\",\n      \"FLDD\",\n      \"FLL\",\n      \"FFL\",\n      \"FFR\",\n      \"FRR\",\n      \"BBDD\",\n      \"BRR\",\n      \"BLL\",\n    ],\n    c: [\n      \"UFF\",\n      \"FFU\",\n      \"DDBB\",\n      \"BBDD\",\n      \"FLDD\",\n      \"FRDD\",\n      \"BRU\",\n      \"BLU\",\n      \"LFL\",\n      \"RFL\",\n      \"DRBR\",\n      \"DLBL\",\n    ],\n  },\n  20: {\n    v: [\n      \"FLPQU\",\n      \"FUGER\",\n      \"FRCAL\",\n      \"HCREI\",\n      \"ISBDH\",\n      \"JSIEG\",\n      \"BSJMK\",\n      \"MQPOK\",\n      \"ONDBK\",\n      \"NOPLA\",\n      \"UQMJG\",\n      \"DNACH\",\n    ],\n    e: [\n      \"FU\",\n      \"FL\",\n      \"FR\",\n      \"EG\",\n      \"ER\",\n      \"EI\",\n      \"SJ\",\n      \"SI\",\n      \"SB\",\n      \"KM\",\n      \"KB\",\n      \"KO\",\n      \"PQ\",\n      \"PO\",\n      \"PL\",\n      \"UG\",\n      \"JG\",\n      \"MQ\",\n      \"UQ\",\n      \"HC\",\n      \"HD\",\n      \"ND\",\n      \"NA\",\n      \"JM\",\n      \"CA\",\n      \"AL\",\n      \"CR\",\n      \"HI\",\n      \"DB\",\n      \"NO\",\n    ],\n    c: [\n      \"FU\",\n      \"UF\",\n      \"GE\",\n      \"EG\",\n      \"JS\",\n      \"SJ\",\n      \"MK\",\n      \"KM\",\n      \"QP\",\n      \"PQ\",\n      \"LA\",\n      \"AL\",\n      \"RC\",\n      \"CR\",\n      \"IH\",\n      \"HI\",\n      \"BD\",\n      \"DB\",\n      \"ON\",\n      \"NO\",\n    ],\n  },\n};\n\n/*\n *  Default orientations for the puzzles in 3D space.  Can be overridden\n *  by puzzleOrientation or puzzleOrientations options.\n *\n *  These are defined to have a strong intuitive vertical (y) direction\n *  since 3D orbital controls need this.  In comments, we list the\n *  preferred initial camera orientation for each puzzle for twizzle;\n *  this information is explicitly given in the twizzle app file.\n */\n// TODO: change this back to a const JSON definition.\nfunction defaultOrientations(): FaceBasedOrientationDescriptionLookup {\n  return {\n    4: [\n      [\"FLR\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // FLR towards viewer\n    6: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // URF towards viewer\n    8: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // FLUR towards viewer\n    12: [\n      [\"U\", [0, 1, 0]],\n      [\"FF\", [0, 0, 1]],\n    ], // F towards viewer\n    20: [\n      [\"GUQMJ\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // F towards viewer\n  };\n}\n\nfunction findelement(a: Quat[][], p: Quat): number {\n  // find something in facenames, vertexnames, edgenames\n  for (let i = 0; i < a.length; i++) {\n    if (a[i][0].dist(p) < eps) {\n      return i;\n    }\n  }\n  throw new Error(\"Element not found\");\n}\n\nexport function getPG3DNamedPuzzles(): {\n  [s: string]: PuzzleDescriptionString;\n} {\n  // get some simple definitions of basic puzzles\n  return PGPuzzles;\n}\n\nexport function getPuzzleDescriptionString(\n  puzzleName: PuzzleName,\n): PuzzleDescriptionString {\n  // get some simple definitions of basic puzzles\n  return PGPuzzles[puzzleName];\n}\n\nexport const PUZZLE_BASE_SHAPES = [\"c\", \"t\", \"o\", \"d\", \"i\"] as const;\nexport type PuzzleBaseShape = typeof PUZZLE_BASE_SHAPES[number];\n\nexport const PUZZLE_CUT_TYPES = [\"f\", \"v\", \"e\"] as const;\nexport type PuzzleCutType = typeof PUZZLE_CUT_TYPES[number];\n\nexport type PuzzleCutDescription = { cutType: PuzzleCutType; distance: number };\nexport type PuzzleDescription = {\n  shape: PuzzleBaseShape;\n  cuts: PuzzleCutDescription[];\n};\n\nexport function parsePuzzleDescription(\n  s: PuzzleDescriptionString,\n): PuzzleDescription | null {\n  // parse a text description\n  const a = s.split(/ /).filter(Boolean);\n  if (a.length % 2 === 0) {\n    return null;\n  }\n  const shape = a[0];\n  if (\n    shape !== \"o\" &&\n    shape !== \"c\" &&\n    shape !== \"i\" &&\n    shape !== \"d\" &&\n    shape !== \"t\"\n  ) {\n    return null;\n  }\n  const cuts: PuzzleCutDescription[] = [];\n  for (let i = 1; i < a.length; i += 2) {\n    if (a[i] !== \"f\" && a[i] !== \"v\" && a[i] !== \"e\") {\n      return null;\n    }\n    cuts.push({\n      cutType: a[i] as PuzzleCutType,\n      distance: parseFloat(a[i + 1]),\n    });\n  }\n  return { shape, cuts };\n}\n\nexport function getPuzzleGeometryByDesc(\n  desc: string,\n  options: PuzzleGeometryOptions = {},\n): PuzzleGeometry {\n  const parsed = parsePuzzleDescription(desc);\n  if (parsed === null) {\n    throw new Error(\"Could not parse the puzzle description\");\n  }\n  const pg = new PuzzleGeometry(\n    parsed,\n    Object.assign({}, { allMoves: true } as PuzzleGeometryOptions, options),\n  );\n  pg.allstickers();\n  pg.genperms();\n  return pg;\n}\n\nexport function getPuzzleGeometryByName(\n  puzzleName: PuzzleName,\n  options?: PuzzleGeometryOptions,\n): PuzzleGeometry {\n  return getPuzzleGeometryByDesc(PGPuzzles[puzzleName], options);\n}\n\nfunction getmovename(\n  geo: any,\n  bits: number[],\n  slices: number,\n): [string, boolean] {\n  // generate a move name based on bits, slice, and geo\n  // if the move name is from the opposite face, say so.\n  // find the face that's turned.\n  let inverted = false;\n  if (slices - bits[1] < bits[0]) {\n    // flip if most of the move is on the other side\n    geo = [geo[2], geo[3], geo[0], geo[1]];\n    bits = [slices - bits[1], slices - bits[0]];\n    inverted = true;\n  }\n  let movenameFamily = geo[0] as string;\n  let movenamePrefix = \"\";\n  if (bits[0] === 0 && bits[1] === slices) {\n    movenameFamily = `${movenameFamily}v`;\n  } else if (bits[0] === bits[1]) {\n    if (bits[1] > 0) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else if (bits[0] === 0) {\n    movenameFamily = movenameFamily.toLowerCase();\n    if (bits[1] > 1) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else {\n    throw new Error(\n      `We only support slice and outer block moves right now. ${bits}`,\n    );\n  }\n  return [movenamePrefix + movenameFamily, inverted];\n}\n\n// split a geometrical element into face names.  Do greedy match.\n// Permit underscores between names.\nfunction splitByFaceNames(s: string, facenames: [Quat[], string][]): string[] {\n  const r: string[] = [];\n  let at = 0;\n  while (at < s.length) {\n    if (at > 0 && at < s.length && s[at] === \"_\") {\n      at++;\n    }\n    let currentMatch = \"\";\n    for (const facename of facenames) {\n      if (\n        s.substr(at).startsWith(facename[1]) &&\n        facename[1].length > currentMatch.length\n      ) {\n        currentMatch = facename[1];\n      }\n    }\n    if (currentMatch !== \"\") {\n      r.push(currentMatch);\n      at += currentMatch.length;\n    } else {\n      throw new Error(`Could not split ${s} into face names.`);\n    }\n  }\n  return r;\n}\n\nfunction toCoords(q: Quat, maxdist: number): number[] {\n  return [q.b / maxdist, -q.c / maxdist, q.d / maxdist];\n}\n\nfunction toFaceCoords(q: Face, maxdist: number): number[] {\n  const r = [];\n  const n = q.length;\n  for (let i = 0; i < n; i++) {\n    const pt = toCoords(q.get(n - i - 1), maxdist);\n    r[3 * i] = pt[0];\n    r[3 * i + 1] = pt[1];\n    r[3 * i + 2] = pt[2];\n  }\n  return r;\n}\n\n/** @category PuzzleGeometry */\nexport class PuzzleGeometry {\n  private rotations: Quat[]; // all members of the rotation group\n  public baseplanerot: Quat[]; // unique rotations of the baseplane\n  private baseplanes: Quat[]; // planes, corresponding to faces\n  private facenames: [Quat[], string][]; // face names\n  private faceplanes: [Quat, string][]; // face planes\n  private edgenames: [Quat, string][]; // edge names\n  private vertexnames: [Quat, string][]; // vertexnames\n  private geonormals: [Quat, string, string][]; // all geometric directions, with names and types\n  private moveplanes: Quat[]; // the planes that split moves\n  private moveplanes2: Quat[]; // the planes that split moves, filtered\n  public moveplanesets: Quat[][]; // the move planes, in parallel sets\n  private moveplanenormals: Quat[]; // one move plane\n  public movesetorders: number[]; // the order of rotations for each move set\n  public movesetgeos: [string, string, string, string, number][]; // geometric feature information for move sets\n  private basefaces: Face[]; // polytope faces before cuts\n  private faces: Face[]; // all the stickers\n  private facecentermass: Quat[]; // center of mass of all faces\n  private baseFaceCount: BaseFaceCount; // number of base faces\n  public stickersperface: number; // number of stickers per face\n  public shortedge: number; // number of stickers per face\n  private markedface: number[]; // given a bitmap of faces, identify the marked one\n  public cubies: number[][]; // the cubies\n  private vertexdistance: number; // vertex distance\n  private edgedistance: number; // edge distance\n  private facetocubie: number[]; // map a face to a cubie index\n  private facetoord: number[]; // map a face to a cubie ord\n  private moverotations: Quat[][]; // move rotations\n  private facelisthash: Map<string, number[]>; // face list by key\n  private cubiesetnames: string[]; // cubie set names\n  private cubieords: number[]; // the size of each orbit\n  private cubiesetnums: number[];\n  private cubieordnums: number[];\n  private orbitoris: number[]; // the orientation size of each orbit\n  private cubievaluemap: number[]; // the map for identical cubies\n  private cubiesetcubies: number[][]; // cubies in each cubie set\n  public cmovesbyslice: number[][][] = []; // cmoves as perms by slice\n  public parsedmovelist: [\n    string | undefined,\n    number,\n    number,\n    number,\n    boolean,\n    number,\n  ][]; // parsed move list\n\n  private duplicatedFaces: number[] = []; // which faces are duplicated\n  private duplicatedCubies: number[] = []; // which cubies are duplicated\n  private fixedCubie: number = -1; // fixed cubie, if any\n  private net: string[][] = [];\n  private colors: any = [];\n  private swizzler: FaceNameSwizzler;\n  public notationMapper: NotationMapper = new NullMapper();\n  private addNotationMapper: string = \"\";\n  private setReidOrder: boolean = false;\n\n  private options: PuzzleGeometryFullOptions;\n\n  constructor(\n    public puzzleDescription: PuzzleDescription,\n    options: PuzzleGeometryOptions,\n  ) {\n    const t1 = tstart(\"genperms\");\n    this.options = new PuzzleGeometryFullOptions(options);\n    if (this.options.verbosity > 0) {\n      console.log(this.header(\"# \"));\n    }\n    this.create(puzzleDescription);\n    tend(t1);\n  }\n\n  public create(puzzleDescription: PuzzleDescription): void {\n    const { shape, cuts } = puzzleDescription;\n\n    // create the shape, doing all the essential geometry\n    // create only goes far enough to figure out how many stickers per\n    // face, and what the short edge is.  If the short edge is too short,\n    // we probably don't want to display or manipulate this one.  How\n    // short is too short is hard to say.\n    this.moveplanes = [];\n    this.moveplanes2 = [];\n    this.faces = [];\n    this.cubies = [];\n    let g = null;\n    switch (shape) {\n      case \"c\": {\n        g = cube();\n        break;\n      }\n      case \"o\": {\n        g = octahedron();\n        break;\n      }\n      case \"i\": {\n        g = icosahedron();\n        break;\n      }\n      case \"t\": {\n        g = tetrahedron();\n        break;\n      }\n      case \"d\": {\n        g = dodecahedron();\n        break;\n      }\n      default:\n        throw new Error(`Bad shape argument: ${shape}`);\n    }\n    this.rotations = closure(g);\n    if (this.options.verbosity) {\n      console.log(`# Rotations: ${this.rotations.length}`);\n    }\n    const baseplane = g[0];\n    this.baseplanerot = uniqueplanes(baseplane, this.rotations);\n    const baseplanes = this.baseplanerot.map((_) => baseplane.rotateplane(_));\n    this.baseplanes = baseplanes;\n    this.baseFaceCount = baseplanes.length as BaseFaceCount;\n    const net = defaultnets()[baseplanes.length];\n    this.net = net;\n    this.colors = defaultcolors()[baseplanes.length];\n    if (this.options.verbosity > 0) {\n      console.log(`# Base planes: ${baseplanes.length}`);\n    }\n    const baseface = getface(baseplanes);\n    const zero = new Quat(0, 0, 0, 0);\n    if (this.options.verbosity > 0) {\n      console.log(`# Face vertices: ${baseface.length}`);\n    }\n    const facenormal = baseplanes[0].makenormal();\n    const edgenormal = baseface[0].sum(baseface[1]).makenormal();\n    const vertexnormal = baseface[0].makenormal();\n    const boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d);\n    if (this.options.verbosity > 0) {\n      console.log(`# Boundary is ${boundary}`);\n    }\n    const planerot = uniqueplanes(boundary, this.rotations);\n    const planes = planerot.map((_) => boundary.rotateplane(_));\n    const firstface = getface(planes);\n    this.edgedistance = firstface[0]\n      .sum(firstface[1])\n      .smul(0.5)\n      .dist(zero);\n    this.vertexdistance = firstface[0].dist(zero);\n    const cutplanes = [];\n    const intersects = [];\n    let sawface = false; // what cuts did we see?\n    let sawedge = false;\n    let sawvertex = false;\n    for (const cut of cuts) {\n      let normal = null;\n      let distance = 0;\n      switch (cut.cutType) {\n        case \"f\": {\n          normal = facenormal;\n          distance = 1;\n          sawface = true;\n          break;\n        }\n        case \"v\": {\n          normal = vertexnormal;\n          distance = this.vertexdistance;\n          sawvertex = true;\n          break;\n        }\n        case \"e\": {\n          normal = edgenormal;\n          distance = this.edgedistance;\n          sawedge = true;\n          break;\n        }\n        default:\n          throw new Error(`Bad cut argument: ${cut.cutType}`);\n      }\n      cutplanes.push(normal.makecut(cut.distance));\n      intersects.push(cut.distance < distance);\n    }\n    if (this.options.addRotations) {\n      if (!sawface) {\n        cutplanes.push(facenormal.makecut(10));\n      }\n      if (!sawvertex) {\n        cutplanes.push(vertexnormal.makecut(10));\n      }\n      if (!sawedge) {\n        cutplanes.push(edgenormal.makecut(10));\n      }\n    }\n    this.basefaces = [];\n    for (const baseplanerot of this.baseplanerot) {\n      const face = baseplanerot.rotateface(firstface);\n      this.basefaces.push(new Face(face));\n    }\n    //\n    //   Determine names for edges, vertices, and planes.  Planes are defined\n    //   by the plane normal/distance; edges are defined by the midpoint;\n    //   vertices are defined by actual point.  In each case we define a name.\n    //   Note that edges have two potential names, and corners have n! where\n    //   n planes meet at a vertex.  We set names by choosing the marked face\n    //   first, and going counterclockwise around.\n    //\n    const facenames: [Quat[], string][] = [];\n    const faceplanes: [Quat, string][] = [];\n    const vertexnames: any[] = [];\n    const edgenames: any[] = [];\n    const edgesperface = firstface.length;\n    function searchaddelement(a: any[], p: Quat, name: any): void {\n      for (const el of a) {\n        if (el[0].dist(p) < eps) {\n          el.push(name);\n          return;\n        }\n      }\n      a.push([p, name]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        searchaddelement(edgenames, midpoint, i);\n      }\n    }\n    const otherfaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const facelist = [];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const el = edgenames[findelement(edgenames, midpoint)];\n        if (i === el[1]) {\n          facelist.push(el[2]);\n        } else if (i === el[2]) {\n          facelist.push(el[1]);\n        } else {\n          throw new Error(\"Could not find edge\");\n        }\n      }\n      otherfaces.push(facelist);\n    }\n    const facenametoindex: any = {};\n    const faceindextoname: string[] = [];\n    faceindextoname.push(net[0][0]);\n    facenametoindex[net[0][0]] = 0;\n    faceindextoname[otherfaces[0][0]] = net[0][1];\n    facenametoindex[net[0][1]] = otherfaces[0][0];\n    for (const neti of net) {\n      const f0 = neti[0];\n      const fi = facenametoindex[f0];\n      if (fi === undefined) {\n        throw new Error(\"Bad edge description; first edge not connected\");\n      }\n      let ii = -1;\n      for (let j = 0; j < otherfaces[fi].length; j++) {\n        const fn2 = faceindextoname[otherfaces[fi][j]];\n        if (fn2 !== undefined && fn2 === neti[1]) {\n          ii = j;\n          break;\n        }\n      }\n      if (ii < 0) {\n        throw new Error(\"First element of a net not known\");\n      }\n      for (let j = 2; j < neti.length; j++) {\n        if (neti[j] === \"\") {\n          continue;\n        }\n        const of = otherfaces[fi][(j + ii - 1) % edgesperface];\n        const fn2 = faceindextoname[of];\n        if (fn2 !== undefined && fn2 !== neti[j]) {\n          throw new Error(\"Face mismatch in net\");\n        }\n        faceindextoname[of] = neti[j];\n        facenametoindex[neti[j]] = of;\n      }\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const faceplane = boundary.rotateplane(this.baseplanerot[i]);\n      const facename = faceindextoname[i];\n      facenames.push([face, facename]);\n      faceplanes.push([faceplane, facename]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const facename = faceindextoname[i];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const jjj = (j + 2) % face.length;\n        const midpoint2 = face[jj].sum(face[jjj]).smul(0.5);\n        const e1 = findelement(edgenames, midpoint);\n        const e2 = findelement(edgenames, midpoint2);\n        searchaddelement(vertexnames, face[jj], [facename, e2, e1]);\n      }\n    }\n    this.swizzler = new FaceNameSwizzler(facenames.map((_) => _[1]));\n    const sep = this.swizzler.prefixFree ? \"\" : \"_\";\n    // fix the edge names; use face precedence order\n    const oridata = orientationDefaults[this.baseFaceCount];\n    const markedface = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      markedface[1 << i] = i;\n    }\n    // FIXME  eliminate the duplications below\n    {\n      const oriprefs = oridata[\"v\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        let bits = 0;\n        for (const i of fn) {\n          bits |= 1 << i;\n        }\n        markedface[bits] = fn[0];\n      }\n    }\n    {\n      const oriprefs = oridata[\"e\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        let bits = 0;\n        for (const i of fn) {\n          bits |= 1 << i;\n        }\n        markedface[bits] = fn[0];\n      }\n    }\n    {\n      const oriprefs = oridata[\"c\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        const bits = (1 << fn[0]) | (1 << this.baseFaceCount);\n        markedface[bits] = fn[1];\n      }\n    }\n    for (let i = 0; i < edgenames.length; i++) {\n      if (edgenames[i].length !== 3) {\n        throw new Error(`Bad length in edge names ${edgenames[i]}`);\n      }\n      const f1 = edgenames[i][1];\n      const f2 = edgenames[i][2];\n      let c1 = faceindextoname[f1];\n      const c2 = faceindextoname[f2];\n      const bits = (1 << f1) | (1 << f2);\n      if (markedface[bits] === f1) {\n        c1 = c1 + sep + c2;\n      } else {\n        c1 = c2 + sep + c1;\n      }\n      edgenames[i] = [edgenames[i][0], c1];\n    }\n    // fix the vertex names; counterclockwise rotations; proper orientation.\n    for (let i = 0; i < vertexnames.length; i++) {\n      let bits = 0;\n      if (vertexnames[i].length < 4) {\n        throw new Error(\"Bad length in vertex names\");\n      }\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        bits |= 1 << facenametoindex[vertexnames[i][j][0]];\n      }\n      const fi = markedface[bits];\n      let st = -1;\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (fi === facenametoindex[vertexnames[i][j][0]]) {\n          st = j;\n        }\n      }\n      if (st < 0) {\n        throw new Error(\n          \"Internal error; couldn't find face name when fixing corners\",\n        );\n      }\n      let r = \"\";\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (j === 1) {\n          r = vertexnames[i][st][0];\n        } else {\n          r = r + sep + vertexnames[i][st][0];\n        }\n        for (let k = 1; k < vertexnames[i].length; k++) {\n          if (vertexnames[i][st][1] === vertexnames[i][k][2]) {\n            st = k;\n            break;\n          }\n        }\n      }\n      vertexnames[i] = [vertexnames[i][0], r];\n    }\n    this.markedface = markedface;\n    if (this.options.verbosity > 1) {\n      console.log(`# Face names: ${facenames.map((_) => _[1]).join(\" \")}`);\n      // TODO\n      console.log(`# Edge names: ${edgenames.map((_) => _[1]).join(\" \")}`);\n      // TODO\n      console.log(`# Vertex names: ${vertexnames.map((_) => _[1]).join(\" \")}`);\n    }\n    const geonormals: [Quat, string, string][] = [];\n    for (const faceplane of faceplanes) {\n      geonormals.push([faceplane[0].makenormal(), faceplane[1], \"f\"]);\n    }\n    for (const edgename of edgenames) {\n      geonormals.push([edgename[0].makenormal(), edgename[1], \"e\"]);\n    }\n    for (const vertexname of vertexnames) {\n      geonormals.push([vertexname[0].makenormal(), vertexname[1], \"v\"]);\n    }\n    this.facenames = facenames;\n    this.faceplanes = faceplanes;\n    this.edgenames = edgenames;\n    this.vertexnames = vertexnames;\n    this.geonormals = geonormals;\n    const geonormalnames = geonormals.map((_) => _[1]);\n    this.swizzler.setGripNames(geonormalnames);\n    if (this.options.verbosity > 0) {\n      console.log(\n        `# Distances: face ${1} edge ${this.edgedistance} vertex ${\n          this.vertexdistance\n        }`,\n      );\n    }\n    // expand cutplanes by rotations.  We only work with one face here.\n    for (let c = 0; c < cutplanes.length; c++) {\n      for (const rotation of this.rotations) {\n        const q = cutplanes[c].rotateplane(rotation);\n        let wasseen = false;\n        for (const moveplane of this.moveplanes) {\n          if (q.sameplane(moveplane)) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          this.moveplanes.push(q);\n          if (intersects[c]) {\n            this.moveplanes2.push(q);\n          }\n        }\n      }\n    }\n    let ft = new FaceTree(firstface);\n    const tar = this.moveplanes2.slice();\n    // we want to use Math.random() here but we can't, because when\n    // we call multiple times we'll get different orbits/layouts.\n    // to resolve this, we use a very simple linear congruential\n    // generator.  for our purposes, the numbers don't need to be\n    // very random.\n    let rval = 31;\n    for (let i = 0; i < tar.length; i++) {\n      const j = i + Math.floor((tar.length - i) * (rval / 65536.0));\n      ft = ft.split(tar[j]);\n      tar[j] = tar[i];\n      rval = (rval * 1657 + 101) % 65536;\n    }\n    const faces = ft.collect([], true);\n    this.faces = faces;\n    if (this.options.verbosity > 0) {\n      console.log(`# Faces is now ${faces.length}`);\n    }\n    this.stickersperface = faces.length;\n    // the faces when rotated don't preserve the vertex order at this\n    // point.  to improve 3d rendering speed, we would like to preserve\n    // vertex order on rotation.  First, let's see what rotations preserve\n    // the base face; these are the ones we want to work with.\n    const simplerot: Quat[] = [];\n    const cm = centermassface(firstface);\n    for (const rotation of this.rotations) {\n      const f = rotation.rotateface(firstface);\n      if (cm.dist(centermassface(f)) < eps) {\n        simplerot.push(rotation);\n      }\n    }\n    const finished = new Array<boolean>(faces.length);\n    const sortme: [number, Quat, number][] = [];\n    for (let i = 0; i < faces.length; i++) {\n      const cm2 = faces[i].centermass();\n      sortme.push([cm.dist(cm2), cm2, i]);\n    }\n    sortme.sort((a, b) => a[0] - b[0]);\n    for (let ii = 0; ii < faces.length; ii++) {\n      const i = sortme[ii][2];\n      if (!finished[i]) {\n        finished[i] = true;\n        for (const rot of simplerot) {\n          const f2 = faces[i].rotate(rot);\n          const cm = f2.centermass();\n          for (let kk = ii + 1; kk < faces.length; kk++) {\n            if (sortme[kk][0] - sortme[ii][0] > eps) {\n              break;\n            }\n            const k = sortme[kk][2];\n            if (!finished[k] && cm.dist(sortme[kk][1]) < eps) {\n              finished[k] = true;\n              faces[k] = f2;\n              break;\n            }\n          }\n        }\n      }\n    }\n    //  Find and report the shortest edge in any of the faces.  If this\n    //  is small the puzzle is probably not practical or displayable.\n    this.shortedge = 1e99;\n    for (const face of faces) {\n      for (let j = 0; j < face.length; j++) {\n        const k = (j + 1) % face.length;\n        const t = face.get(j).dist(face.get(k));\n        if (t < this.shortedge) {\n          this.shortedge = t;\n        }\n      }\n    }\n    if (this.options.verbosity > 0) {\n      console.log(`# Short edge is ${this.shortedge}`);\n    }\n    // add nxnxn cube notation if it has cube face moves\n    if (shape === \"c\" && sawface && !sawedge && !sawvertex) {\n      // In this case the mapper adding is deferred until we\n      // know the number of slices.\n      this.addNotationMapper = \"NxNxNCubeMapper\";\n      // try to set Reid order of the cubies within an orbit\n      this.setReidOrder = true;\n    }\n    if (shape === \"c\" && sawvertex && !sawface && !sawedge) {\n      this.addNotationMapper = \"SkewbMapper\";\n    }\n    if (shape === \"t\" && (sawvertex || sawface) && !sawedge) {\n      this.addNotationMapper = \"PyraminxOrTetraminxMapper\";\n    }\n    if (shape === \"o\" && sawface) {\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\"F\", \"D\", \"L\", \"BL\", \"R\", \"U\", \"BR\", \"B\"]),\n      );\n      if (!(sawedge || sawvertex)) {\n        this.addNotationMapper = \"FTOMapper\";\n      }\n    }\n    if (shape === \"d\" && sawface) {\n      this.addNotationMapper = \"MegaminxMapper\";\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\n          \"U\",\n          \"F\",\n          \"L\",\n          \"BL\",\n          \"BR\",\n          \"R\",\n          \"FR\",\n          \"FL\",\n          \"DL\",\n          \"B\",\n          \"DR\",\n          \"D\",\n        ]),\n      );\n    }\n  }\n\n  private keyface(face: Face): string {\n    return this.keyface2(face.centermass());\n  }\n\n  private keyface2(cm: Quat): string {\n    // take a face and figure out the sides of each move plane\n    let s = \"\";\n    const sfcc = String.fromCharCode;\n    for (const moveplaneset of this.moveplanesets) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        if (t < 47) {\n          s = s + sfcc(33 + t);\n        } else if (t < 47 + 47 * 47) {\n          s = s + sfcc(33 + 47 + Math.floor(t / 47) - 1) + sfcc(33 + (t % 47));\n        } else if (t < 47 + 47 * 47 + 47 * 47 * 47) {\n          s =\n            s +\n            sfcc(33 + 47 + Math.floor((t - 47) / (47 * 47) - 1)) +\n            sfcc(33 + 47 + (Math.floor((t - 47) / 47) % 47)) +\n            sfcc(33 + (t % 47));\n        } else {\n          throw Error(\"Too many slices for cubie encoding\");\n        }\n      }\n    }\n    return s;\n  }\n\n  // same as above, but instead of returning an encoded string, return\n  // an array with offsets.\n  private keyface3(face: Face): number[] {\n    const cm = face.centermass();\n    // take a face and figure out the sides of each move plane\n    const r = [];\n    for (const moveplaneset of this.moveplanesets) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        r.push(t);\n      }\n    }\n    return r;\n  }\n\n  private findface(cm: Quat): number {\n    const key = this.keyface2(cm);\n    const arr = this.facelisthash.get(key)!;\n    if (arr.length === 1) {\n      return arr[0];\n    }\n    for (let i = 0; i + 1 < arr.length; i++) {\n      const face2 = this.facelisthash.get(key)![i];\n      if (Math.abs(cm.dist(this.facecentermass[face2])) < eps) {\n        return face2;\n      }\n    }\n    return arr[arr.length - 1];\n  }\n\n  private project2d(\n    facen: number,\n    edgen: number,\n    targvec: Quat[],\n  ): [Quat, Quat, Quat] {\n    // calculate geometry to map a particular edge of a particular\n    //  face to a given 2D vector.  The face is given as an index into the\n    //  facenames/baseplane arrays, and the edge is given as an offset into\n    //  the vertices.\n    const face = this.facenames[facen][0];\n    const edgen2 = (edgen + 1) % face.length;\n    const plane = this.baseplanes[facen];\n    let x0 = face[edgen2].sub(face[edgen]);\n    const olen = x0.len();\n    x0 = x0.normalize();\n    const y0 = x0.cross(plane).normalize();\n    let delta = targvec[1].sub(targvec[0]);\n    const len = delta.len() / olen;\n    delta = delta.normalize();\n    const cosr = delta.b;\n    const sinr = delta.c;\n    const x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len);\n    const y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len);\n    const off = new Quat(\n      0,\n      targvec[0].b - x1.dot(face[edgen]),\n      targvec[0].c - y1.dot(face[edgen]),\n      0,\n    );\n    return [x1, y1, off];\n  }\n\n  public allstickers(): void {\n    const t1 = tstart(\"allstickers\");\n    // next step is to calculate all the stickers and orbits\n    // We do enough work here to display the cube on the screen.\n    // take our newly split base face and expand it by the rotation matrix.\n    // this generates our full set of \"stickers\".\n    this.faces = expandfaces(this.baseplanerot, this.faces);\n    if (this.options.verbosity > 0) {\n      console.log(`# Total stickers is now ${this.faces.length}`);\n    }\n    this.facecentermass = new Array(this.faces.length);\n    for (let i = 0; i < this.faces.length; i++) {\n      this.facecentermass[i] = this.faces[i].centermass();\n    }\n    // Split moveplanes into a list of parallel planes.\n    const moveplanesets: Quat[][] = [];\n    const moveplanenormals: Quat[] = [];\n    // get the normals, first, from unfiltered moveplanes.\n    for (const q of this.moveplanes) {\n      const qnormal = q.makenormal();\n      let wasseen = false;\n      for (const moveplanenormal of moveplanenormals) {\n        if (qnormal.sameplane(moveplanenormal.makenormal())) {\n          wasseen = true;\n        }\n      }\n      if (!wasseen) {\n        moveplanenormals.push(qnormal);\n        moveplanesets.push([]);\n      }\n    }\n    for (const q of this.moveplanes2) {\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanenormals.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moveplanesets[j].push(q);\n          break;\n        }\n      }\n    }\n    // make the normals all face the same way in each set.\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const q: Quat[] = moveplanesets[i].map((_) => _.normalizeplane());\n      const goodnormal = moveplanenormals[i];\n      for (let j = 0; j < q.length; j++) {\n        if (q[j].makenormal().dist(goodnormal) > eps) {\n          q[j] = q[j].smul(-1);\n        }\n      }\n      q.sort((a, b) => a.a - b.a);\n      moveplanesets[i] = q;\n    }\n    this.moveplanesets = moveplanesets;\n    this.moveplanenormals = moveplanenormals;\n    const sizes = moveplanesets.map((_) => _.length);\n    if (this.options.verbosity > 0) {\n      console.log(`# Move plane sets: ${sizes}`);\n    }\n    // for each of the move planes, find the rotations that are relevant\n    const moverotations: Quat[][] = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      moverotations.push([]);\n    }\n    for (const q of this.rotations) {\n      if (Math.abs(Math.abs(q.a) - 1) < eps) {\n        continue;\n      }\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moverotations[j].push(q);\n          break;\n        }\n      }\n    }\n    this.moverotations = moverotations;\n    //  Sort the rotations by the angle of rotation.  A bit tricky because\n    //  while the norms should be the same, they need not be.  So we start\n    //  by making the norms the same, and then sorting.\n    for (let i = 0; i < moverotations.length; i++) {\n      const r = moverotations[i];\n      const goodnormal = r[0].makenormal();\n      for (let j = 0; j < r.length; j++) {\n        if (goodnormal.dist(r[j].makenormal()) > eps) {\n          r[j] = r[j].smul(-1);\n        }\n      }\n      r.sort((a, b) => a.angle() - b.angle());\n      if (moverotations[i][0].dot(moveplanenormals[i]) < 0) {\n        r.reverse();\n      }\n    }\n    const sizes2 = moverotations.map((_) => 1 + _.length);\n    this.movesetorders = sizes2;\n    const movesetgeos: [string, string, string, string, number][] = [];\n    let gtype = \"?\";\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const p0 = moveplanenormals[i];\n      let neg = null;\n      let pos = null;\n      for (const geonormal of this.geonormals) {\n        const d = p0.dot(geonormal[0]);\n        if (Math.abs(d - 1) < eps) {\n          pos = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        } else if (Math.abs(d + 1) < eps) {\n          neg = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        }\n      }\n      if (pos === null || neg === null) {\n        throw new Error(\"Saw positive or negative sides as null\");\n      }\n      movesetgeos.push([\n        pos[0],\n        pos[1],\n        neg[0],\n        neg[1],\n        1 + moveplanesets[i].length,\n      ]);\n      if (this.addNotationMapper === \"NxNxNCubeMapper\" && gtype === \"f\") {\n        this.notationMapper = new NxNxNCubeMapper(1 + moveplanesets[i].length);\n        this.addNotationMapper = \"\";\n      }\n      if (\n        this.addNotationMapper === \"SkewbMapper\" &&\n        moveplanesets[0].length === 1\n      ) {\n        this.notationMapper = new SkewbNotationMapper(this.swizzler);\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"PyraminxOrTetraminxMapper\") {\n        if (\n          moveplanesets[0].length === 2 &&\n          moveplanesets[0][0].a === 0.333333333333333 &&\n          moveplanesets[0][1].a === 1.66666666666667\n        ) {\n          this.notationMapper = new PyraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        } else {\n          this.notationMapper = new TetraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        }\n      }\n      if (this.addNotationMapper === \"MegaminxMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new MegaminxScramblingNotationMapper(\n            this.notationMapper,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"FTOMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new FTONotationMapper(\n            this.notationMapper,\n            this.swizzler,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n    }\n    this.movesetgeos = movesetgeos;\n    //  Cubies are split by move plane sets.  For each cubie we can\n    //  average its points to find a point on the interior of that\n    //  cubie.  We can then check that point against all the move\n    //  planes and from that derive a coordinate for the cubie.\n    //  This also works for faces; no face should ever lie on a move\n    //  plane.  This allows us to take a set of stickers and break\n    //  them up into cubie sets.\n    const facelisthash = new Map();\n    const faces = this.faces;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      const s = this.keyface(face);\n      if (!facelisthash.get(s)) {\n        facelisthash.set(s, [i]);\n      } else {\n        const arr = facelisthash.get(s)!;\n        arr.push(i);\n        //  If we find a core cubie, split it up into multiple cubies,\n        //  because ksolve doesn't handle orientations that are not\n        //  cyclic, and the rotation group of the core is not cyclic.\n        if (arr.length === this.baseFaceCount) {\n          if (this.options.verbosity > 0) {\n            console.log(\"# Splitting core.\");\n          }\n          for (let suff = 0; suff < arr.length; suff++) {\n            const s2 = `${s} ${suff}`;\n            facelisthash.set(s2, [arr[suff]]);\n          }\n        }\n      }\n    }\n    this.facelisthash = facelisthash;\n    if (this.options.verbosity > 0) {\n      console.log(`# Cubies: ${facelisthash.size}`);\n    }\n    const cubies: number[][] = [];\n    const facetocubie = [];\n    const facetoord = [];\n    for (const facelist of facelisthash.values()) {\n      if (facelist.length === this.baseFaceCount) {\n        // this is the original \"cubie\" of a split core; we ignore it.\n        continue;\n      }\n      //  Sort the faces around each corner so they are counterclockwise.  Only\n      //  relevant for cubies that actually are corners (three or more\n      //  faces).  In general cubies might have many faces; for icosohedrons\n      //  there are five faces on the corner cubies.\n      if (facelist.length > 1) {\n        const cm = facelist.map((_: number) => faces[_].centermass());\n        const cmall = centermassface(cm);\n        for (let looplimit = 0; facelist.length > 2; looplimit++) {\n          let changed = false;\n          for (let i = 0; i < facelist.length; i++) {\n            const j = (i + 1) % facelist.length;\n            // var ttt = cmall.dot(cm[i].cross(cm[j])) ; // TODO\n            if (cmall.dot(cm[i].cross(cm[j])) < 0) {\n              const u = cm[i];\n              cm[i] = cm[j];\n              cm[j] = u;\n              const v = facelist[i];\n              facelist[i] = facelist[j];\n              facelist[j] = v;\n              changed = true;\n            }\n          }\n          if (!changed) {\n            break;\n          }\n          if (looplimit > 1000) {\n            throw new Error(\"Bad epsilon math; too close to border\");\n          }\n        }\n        // set the orientations by finding the marked face and putting it first.\n        let bits = 0;\n        for (const f of facelist) {\n          bits |= 1 << Math.floor(f / this.stickersperface);\n        }\n        const markedface = this.markedface[bits]!;\n        let mini = -1;\n        for (let i = 0; i < facelist.length; i++) {\n          if (Math.floor(facelist[i] / this.stickersperface) === markedface) {\n            mini = i;\n          }\n        }\n        if (mini < 0) {\n          throw new Error(\"Could not find marked face in list\");\n        }\n        if (mini !== 0) {\n          const ofacelist = facelist.slice();\n          for (let i = 0; i < facelist.length; i++) {\n            facelist[i] = ofacelist[(mini + i) % facelist.length];\n          }\n        }\n      }\n      for (let j = 0; j < facelist.length; j++) {\n        const k = facelist[j];\n        facetocubie[k] = cubies.length;\n        facetoord[k] = j;\n      }\n      cubies.push(facelist);\n    }\n    this.cubies = cubies;\n    this.facetocubie = facetocubie;\n    this.facetoord = facetoord;\n    //  Calculate the orbits of each cubie.  Assumes we do all moves.\n    //  Also calculates which cubies are identical.\n    const typenames = [\"?\", \"CENTERS\", \"EDGES\", \"CORNERS\", \"C4RNER\", \"C5RNER\"];\n    const cubiesetnames = [];\n    const cubietypecounts = [0, 0, 0, 0, 0, 0];\n    const orbitoris = [];\n    const seen = [];\n    let cubiesetnum = 0;\n    const cubiesetnums = [];\n    const cubieordnums = [];\n    const cubieords = [];\n    const cubievaluemap = [];\n    // Later we will make this smarter to use a get color for face function\n    // so we support puzzles with multiple faces the same color\n    const getcolorkey = (cubienum: number): string => {\n      return cubies[cubienum].map((_) => this.getfaceindex(_)).join(\" \");\n    };\n    const cubiesetcubies: any = [];\n    for (let i = 0; i < cubies.length; i++) {\n      const cubie = cubies[i];\n      if (cubie.length === 0) {\n        continue;\n      }\n      if (seen[i]) {\n        continue;\n      }\n      const cubiekeymap: any = {};\n      let cubievalueid = 0;\n      cubieords.push(0);\n      cubiesetcubies.push([]);\n      const facecnt = cubie.length;\n      const typectr = cubietypecounts[facecnt]++;\n      let typename = typenames[facecnt];\n      if (typename === undefined || facecnt === this.baseFaceCount) {\n        typename = \"CORE\";\n      }\n      typename = typename + (typectr === 0 ? \"\" : typectr + 1);\n      cubiesetnames[cubiesetnum] = typename;\n      orbitoris[cubiesetnum] = facecnt;\n      const queue = [i];\n      let qg = 0;\n      seen[i] = true;\n      while (qg < queue.length) {\n        const cind = queue[qg++];\n        const cubiecolorkey = getcolorkey(cind);\n        if (cubie.length > 1 || cubiekeymap[cubiecolorkey] === undefined) {\n          cubiekeymap[cubiecolorkey] = cubievalueid++;\n        }\n        cubievaluemap[cind] = cubiekeymap[cubiecolorkey];\n        cubiesetnums[cind] = cubiesetnum;\n        cubiesetcubies[cubiesetnum].push(cind);\n        cubieordnums[cind] = cubieords[cubiesetnum]++;\n        if (queue.length < this.rotations.length) {\n          const cm = this.facecentermass[cubies[cind][0]];\n          for (const moverotation of moverotations) {\n            const tq =\n              this.facetocubie[this.findface(cm.rotatepoint(moverotation[0]))];\n            if (!seen[tq]) {\n              queue.push(tq);\n              seen[tq] = true;\n            }\n          }\n        }\n      }\n      cubiesetnum++;\n    }\n    if (\n      this.setReidOrder &&\n      4 <= this.stickersperface &&\n      this.stickersperface <= 9\n    ) {\n      const reidorder = [\n        [\n          \"UF\",\n          \"UR\",\n          \"UB\",\n          \"UL\",\n          \"DF\",\n          \"DR\",\n          \"DB\",\n          \"DL\",\n          \"FR\",\n          \"FL\",\n          \"BR\",\n          \"BL\",\n        ],\n        [\"UFR\", \"URB\", \"UBL\", \"ULF\", \"DRF\", \"DFL\", \"DLB\", \"DBR\"],\n        [\"U\", \"L\", \"F\", \"R\", \"B\", \"D\"],\n      ];\n      const reidmap: { [key: number]: number } = {};\n      for (const cubie of reidorder) {\n        for (let j = 0; j < cubie.length; j++) {\n          let mask = 0;\n          for (let k = 0; k < cubie[j].length; k++) {\n            mask |= 1 << (cubie[j].charCodeAt(k) - 65);\n          }\n          reidmap[mask] = j;\n        }\n      }\n      for (const cubieset of cubiesetcubies) {\n        for (const cubienum of cubieset) {\n          let mask = 0;\n          for (const cubie of cubies[cubienum]) {\n            mask |=\n              1 <<\n              (this.facenames[this.getfaceindex(cubie)][1].charCodeAt(0) - 65);\n          }\n          cubieordnums[cubienum] = reidmap[mask];\n        }\n      }\n    }\n    this.cubiesetnums = cubiesetnums;\n    this.cubieordnums = cubieordnums;\n    this.cubiesetnames = cubiesetnames;\n    this.cubieords = cubieords;\n    this.orbitoris = orbitoris;\n    this.cubievaluemap = cubievaluemap;\n    this.cubiesetcubies = cubiesetcubies;\n    // if we fix a cubie, find a cubie to fix\n    if (this.options.fixedPieceType !== null) {\n      for (let i = 0; i < cubies.length; i++) {\n        if (\n          (this.options.fixedPieceType === \"v\" && cubies[i].length > 2) ||\n          (this.options.fixedPieceType === \"e\" && cubies[i].length === 2) ||\n          (this.options.fixedPieceType === \"f\" && cubies[i].length === 1)\n        ) {\n          this.fixedCubie = i;\n          break;\n        }\n      }\n      if (this.fixedCubie < 0) {\n        throw new Error(\n          `Could not find a cubie of type ${this.options.fixedPieceType} to fix.`,\n        );\n      }\n    }\n    // show the orbits\n    if (this.options.verbosity > 0) {\n      console.log(`# Cubie orbit sizes ${cubieords}`);\n    }\n    tend(t1);\n  }\n\n  public unswizzle(mv: Move): Move | null {\n    const newmv = this.notationMapper.notationToInternal(mv);\n    if (newmv === null) {\n      return null;\n    }\n    return newmv.modified({ family: this.swizzler.unswizzle(newmv.family) });\n  }\n\n  // We use an extremely permissive parse here; any character but\n  // digits are allowed in a family name.\n  private stringToBlockMove(mv: string): Move {\n    // parse a move from the command line\n    const re = RegExp(\"^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$\");\n    const p = mv.match(re);\n    if (p === null) {\n      throw new Error(`Bad move passed ${mv}`);\n    }\n    const grip = p[4];\n    let loslice = undefined;\n    let hislice = undefined;\n    if (p[2] !== undefined) {\n      if (p[3] === undefined) {\n        throw new Error(\"Missing second number in range\");\n      }\n      loslice = parseInt(p[2], 10);\n    }\n    if (p[3] !== undefined) {\n      hislice = parseInt(p[3], 10);\n    }\n    let amountstr = \"1\";\n    let amount = 1;\n    if (p[5] !== undefined) {\n      amountstr = p[5];\n      if (amountstr[0] === \"'\") {\n        amountstr = `-${amountstr.substring(1)}`;\n      }\n      amount = parseInt(amountstr, 10);\n    }\n    return new Move(new QuantumMove(grip, hislice, loslice), amount);\n  }\n\n  public parseMove(\n    move: Move,\n  ): [string | undefined, number, number, number, boolean, number] {\n    const bm = this.notationMapper.notationToInternal(move); // pluggable notation\n    if (bm === null) {\n      throw new Error(`Bad move ${move.family}`);\n    }\n    move = bm;\n    let grip = move.family;\n    let fullrotation = false;\n    if (grip.endsWith(\"v\") && grip[0] <= \"Z\") {\n      if (move.innerLayer !== undefined || move.outerLayer !== undefined) {\n        throw new Error(\"Cannot use a prefix with full cube rotations\");\n      }\n      grip = grip.slice(0, -1);\n      fullrotation = true;\n    }\n    if (grip.endsWith(\"w\") && grip[0] <= \"Z\") {\n      grip = grip.slice(0, -1).toLowerCase();\n    }\n    let geo;\n    let msi = -1;\n    const geoname = this.swizzler.unswizzle(grip);\n    let firstgrip = false;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const g = this.movesetgeos[i];\n      if (geoname === g[0]) {\n        firstgrip = true;\n        geo = g;\n        msi = i;\n      }\n      if (geoname === g[2]) {\n        firstgrip = false;\n        geo = g;\n        msi = i;\n      }\n    }\n    let loslice = 1;\n    let hislice = 1;\n    if (grip.toUpperCase() !== grip) {\n      hislice = 2;\n    }\n    if (geo === undefined) {\n      throw new Error(`Bad grip in move ${move.family}`);\n    }\n    if (move.outerLayer !== undefined) {\n      loslice = move.outerLayer;\n    }\n    if (move.innerLayer !== undefined) {\n      if (move.outerLayer === undefined) {\n        hislice = move.innerLayer;\n        // big assumption here!  if outerlayer not specified, but inner\n        // layer is (like 2U), we use the case of the family (upper vs\n        // lower) to decide if it should be a slice turn or a wide turn.\n        if (grip <= \"Z\") {\n          // uppercase; slice move\n          loslice = hislice;\n        } else {\n          // lowercase; wide move\n          loslice = 1;\n        }\n      } else {\n        hislice = move.innerLayer;\n      }\n    }\n    loslice--;\n    hislice--;\n    if (fullrotation) {\n      loslice = 0;\n      hislice = this.moveplanesets[msi].length;\n    }\n    if (\n      loslice < 0 ||\n      loslice > this.moveplanesets[msi].length ||\n      hislice < 0 ||\n      hislice > this.moveplanesets[msi].length\n    ) {\n      throw new Error(\n        `Bad slice spec ${loslice} ${hislice} vs ${this.moveplanesets[msi].length}`,\n      );\n    }\n    if (\n      !permissivieMoveParsing &&\n      loslice === 0 &&\n      hislice === this.moveplanesets[msi].length &&\n      !fullrotation\n    ) {\n      throw new Error(\n        \"! full puzzle rotations must be specified with v suffix.\",\n      );\n    }\n    return [undefined, msi, loslice, hislice, firstgrip, move.amount];\n  }\n\n  private parsemove(\n    mv: string,\n  ): [string | undefined, number, number, number, boolean, number] {\n    const r = this.parseMove(this.stringToBlockMove(mv));\n    r[0] = mv;\n    return r;\n  }\n\n  public genperms(): void {\n    const t1 = tstart(\"genperms\");\n    // generate permutations for moves\n    if (this.cmovesbyslice.length > 0) {\n      // did this already?\n      return;\n    }\n    const cmovesbyslice = [];\n    // if orientCenters is set, we find all cubies that have only one\n    // sticker and that sticker is in the center of a face, and we\n    // introduce duplicate stickers so we can orient them properly.\n    //\n    //  We also rotate the vertices of the face to enforce the orientation\n    //  preferences for the oriented center stickers.\n    if (this.options.orientCenters) {\n      for (let k = 0; k < this.cubies.length; k++) {\n        if (this.cubies[k].length === 1) {\n          const kk = this.cubies[k][0];\n          const i = this.getfaceindex(kk);\n          const center = this.basefaces[i].centermass();\n          if (center.dist(this.facecentermass[kk]) < eps) {\n            const bits = (1 << i) | (1 << this.baseFaceCount);\n            const towards = this.markedface[bits];\n            const normal = this.baseplanes[towards].makenormal();\n            let hiv = -1;\n            let hii = -1;\n            for (let ii = 0; ii < this.faces[kk].length; ii++) {\n              const pt = this.faces[kk].get(ii);\n              const t = normal.dot(pt.sub(center));\n              if (t > hiv) {\n                hiv = t;\n                hii = ii;\n              }\n            }\n            // if two pts have the same distance, prefer the second\n            const hii2 = (hii + 1) % this.faces[kk].length;\n            if (\n              Math.abs(normal.dot(this.faces[kk].get(hii2).sub(center)) - hiv) <\n              eps\n            ) {\n              hii = hii2;\n            }\n            // remake the face to preserve orientations\n            if (hii !== 0) {\n              const qs = [];\n              for (let ii = 0; ii < this.faces[kk].length; ii++) {\n                qs.push(this.faces[kk].get((ii + hii) % this.faces[kk].length));\n              }\n              this.faces[kk] = new Face(qs);\n            }\n            const o = this.basefaces[i].length;\n            for (let m = 1; m < o; m++) {\n              this.cubies[k].push(this.cubies[k][m - 1]);\n            }\n            this.duplicatedFaces[kk] = o;\n            this.duplicatedCubies[k] = o;\n            this.orbitoris[this.cubiesetnums[k]] = o;\n          }\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slicenum = [];\n      const slicecnts = [moveplaneset.length + 1, 0];\n      let bhi = 1;\n      while (bhi * 2 <= moveplaneset.length) {\n        bhi *= 2;\n      }\n      for (let i = 0; i < this.faces.length; i++) {\n        let t = 0;\n        if (moveplaneset.length > 0) {\n          const dv = this.facecentermass[i].dot(moveplaneset[0]);\n          for (let b = bhi; b > 0; b >>= 1) {\n            if (\n              t + b <= moveplaneset.length &&\n              dv > moveplaneset[t + b - 1].a\n            ) {\n              t += b;\n            }\n          }\n          t = moveplaneset.length - t;\n        }\n        slicenum.push(t);\n        while (slicecnts.length <= t) {\n          slicecnts.push(0);\n        }\n        slicecnts[t]++;\n      }\n      const axiscmoves = new Array(slicecnts.length);\n      for (let sc = 0; sc < slicecnts.length; sc++) {\n        axiscmoves[sc] = [];\n      }\n      const cubiedone = [];\n      for (let i = 0; i < this.faces.length; i++) {\n        if (slicenum[i] < 0) {\n          continue;\n        }\n        const b = [this.facetocubie[i], this.facetoord[i]];\n        let cm = this.facecentermass[i];\n        const ocm = cm;\n        let fi2 = i;\n        const sc = slicenum[fi2];\n        for (;;) {\n          slicenum[fi2] = -1;\n          const cm2 = cm.rotatepoint(this.moverotations[k][0]);\n          if (cm2.dist(ocm) < eps) {\n            break;\n          }\n          fi2 = this.findface(cm2);\n          b.push(this.facetocubie[fi2], this.facetoord[fi2]);\n          cm = cm2;\n        }\n        // If an oriented center is moving, we need to figure out\n        // the appropriate new orientation.  Normally we use the cubie\n        // sticker identity to locate, but this doesn't work here.\n        // Instead we need to redo the geometry of the sticker itself\n        // rotating and figure out how that maps to the destination\n        // sticker.\n        //\n        // We only need to do this for central center stickers: those\n        // where the face vertex goes through the center.  The others\n        // don't actually need orientation because they can only be\n        // in one orientation by physical constraints.  (You can't spin\n        // a point or cross sticker on the 5x5x5, for example.)\n        //\n        // This also simplifies things because it means the actual\n        // remapping has the same order as the moves themselves.\n        //\n        // The center may or may not have been duplicated at this point.\n        //\n        // The move moving the center might not be the same modulo as the\n        // center itself.\n        if (\n          b.length > 2 &&\n          this.options.orientCenters &&\n          (this.cubies[b[0]].length === 1 || this.duplicatedCubies[b[0]] > 1)\n        ) {\n          // is this a real center cubie, around an axis?\n          if (\n            this.facecentermass[i].dist(\n              this.basefaces[this.getfaceindex(i)].centermass(),\n            ) < eps\n          ) {\n            // how does remapping of the face/point set map to the original?\n            let face1 = this.faces[this.cubies[b[0]][0]];\n            for (let ii = 0; ii < b.length; ii += 2) {\n              const face0 = this.faces[this.cubies[b[ii]][0]];\n              let o = -1;\n              for (let jj = 0; jj < face1.length; jj++) {\n                if (face0.get(jj).dist(face1.get(0)) < eps) {\n                  o = jj;\n                  break;\n                }\n              }\n              if (o < 0) {\n                throw new Error(\n                  \"Couldn't find rotation of center faces; ignoring for now.\",\n                );\n              } else {\n                b[ii + 1] = o;\n                face1 = face1.rotate(this.moverotations[k][0]);\n              }\n            }\n          }\n        }\n        // b.length === 2 means a sticker is spinning in place.\n        // in this case we add duplicate stickers\n        // so that we can make it animate properly in a 3D world.\n        if (b.length === 2 && this.options.orientCenters) {\n          for (let ii = 1; ii < this.movesetorders[k]; ii++) {\n            if (sc === 0) {\n              b.push(b[0], ii);\n            } else {\n              b.push(\n                b[0],\n                (this.movesetorders[k] - ii) % this.movesetorders[k],\n              );\n            }\n          }\n        }\n        if (b.length > 2 && !cubiedone[b[0]]) {\n          if (b.length !== 2 * this.movesetorders[k]) {\n            throw new Error(\"Bad length in perm gen\");\n          }\n          for (const v of b) {\n            axiscmoves[sc].push(v);\n          }\n        }\n        for (let j = 0; j < b.length; j += 2) {\n          cubiedone[b[j]] = true;\n        }\n      }\n      for (let kk = 0; kk < axiscmoves.length; kk++) {\n        axiscmoves[kk] = axiscmoves[kk].slice();\n      }\n      cmovesbyslice.push(axiscmoves);\n    }\n    this.cmovesbyslice = cmovesbyslice;\n    if (this.options.moveList) {\n      const parsedmovelist: [\n        string | undefined,\n        number,\n        number,\n        number,\n        boolean,\n        number,\n      ][] = [];\n      // make sure the movelist makes sense based on the geos.\n      for (const moveString of this.options.moveList) {\n        parsedmovelist.push(this.parsemove(moveString));\n      }\n      this.parsedmovelist = parsedmovelist;\n    }\n    this.facelisthash.clear();\n    this.facecentermass = [];\n    tend(t1);\n  }\n\n  private getboundarygeometry(): any {\n    // get the boundary geometry\n    return {\n      baseplanes: this.baseplanes,\n      facenames: this.facenames,\n      faceplanes: this.faceplanes,\n      vertexnames: this.vertexnames,\n      edgenames: this.edgenames,\n      geonormals: this.geonormals,\n    };\n  }\n\n  private getmovesets(k: number): any {\n    // get the move sets we support based on slices\n    // for even values we omit the middle \"slice\".  This isn't perfect\n    // but it is what we do for now.\n    // if there was a move list specified, pull values from that\n    const slices = this.moveplanesets[k].length;\n    let r: any[] = [];\n    if (this.parsedmovelist !== undefined) {\n      for (const parsedmove of this.parsedmovelist) {\n        if (parsedmove[1] !== k) {\n          continue;\n        }\n        if (parsedmove[4]) {\n          r.push([parsedmove[2], parsedmove[3]]);\n        } else {\n          r.push([slices - parsedmove[3], slices - parsedmove[2]]);\n        }\n        r.push(parsedmove[5]);\n      }\n    } else if (this.options.vertexMoves && !this.options.allMoves) {\n      const msg = this.movesetgeos[k];\n      if (msg[1] !== msg[3]) {\n        for (let i = 0; i < slices; i++) {\n          if (msg[1] !== \"v\") {\n            if (this.options.outerBlockMoves) {\n              r.push([i + 1, slices]);\n            } else {\n              r.push([i + 1]);\n            }\n            r.push(1);\n          } else {\n            if (this.options.outerBlockMoves) {\n              r.push([0, i]);\n            } else {\n              r.push([i, i]);\n            }\n            r.push(1);\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i <= slices; i++) {\n        if (!this.options.allMoves && i + i === slices) {\n          continue;\n        }\n        if (this.options.outerBlockMoves) {\n          if (i + i > slices) {\n            r.push([i, slices]);\n          } else {\n            r.push([0, i]);\n          }\n        } else {\n          r.push([i, i]);\n        }\n        r.push(1);\n      }\n    }\n    if (this.fixedCubie >= 0) {\n      const dep = this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[k];\n      const newr = [];\n      for (let i = 0; i < r.length; i += 2) {\n        let o = r[i];\n        if (dep >= o[0] && dep <= o[1]) {\n          if (o[0] === 0) {\n            o = [o[1] + 1, slices];\n          } else if (slices === o[1]) {\n            o = [0, o[0] - 1];\n          } else {\n            throw Error(\"fixed cubie option would disconnect move\");\n          }\n        }\n        let found = false;\n        for (let j = 0; j < newr.length; j += 2) {\n          if (\n            newr[j][0] === o[0] &&\n            newr[j][1] === o[1] &&\n            newr[j + 1] === r[i + 1]\n          ) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          newr.push(o);\n          newr.push(r[i + 1]);\n        }\n      }\n      r = newr;\n    }\n    // TODO\n    return r;\n  }\n\n  private graybyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 &&\n        (this.options.grayCenters || !this.options.includeCenterOrbits)) ||\n      (ori === 2 &&\n        (this.options.grayEdges || !this.options.includeEdgeOrbits)) ||\n      (ori > 2 &&\n        (this.options.grayCorners || !this.options.includeCornerOrbits))\n    );\n  }\n\n  private skipbyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 && !this.options.includeCenterOrbits) ||\n      (ori === 2 && !this.options.includeEdgeOrbits) ||\n      (ori > 2 && !this.options.includeCornerOrbits)\n    );\n  }\n\n  private skipcubie(fi: number): boolean {\n    return this.skipbyori(fi);\n  }\n\n  private header(comment: string): string {\n    return comment + copyright + \"\\n\" + comment + \"\\n\";\n  }\n\n  public writegap(): string {\n    // write out a gap set of generators\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    for (let i = 0; i < os.moveops.length; i++) {\n      let movename = `M_${externalName(this.notationMapper, os.movenames[i])}`;\n      let doinv = false;\n      if (movename[movename.length - 1] === \"'\") {\n        movename = movename.substring(0, movename.length - 1);\n        doinv = true;\n      }\n      // gap doesn't like angle brackets in IDs\n      mvs.push(movename);\n      if (doinv) {\n        r.push(`${movename}:=${os.moveops[i].toPerm().inv().toGap()};`);\n      } else {\n        r.push(`${movename}:=${os.moveops[i].toPerm().toGap()};`);\n      }\n    }\n    r.push(\"Gen:=[\");\n    r.push(mvs.join(\",\"));\n    r.push(\"];\");\n    const ip = os.solved.identicalPieces();\n    r.push(\n      `ip:=[${ip\n        .map((_) => `[${_.map((__) => __ + 1).join(\",\")}]`)\n        .join(\",\")}];`,\n    );\n    r.push(\"# Size(Group(Gen));\");\n    r.push(\"# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));\");\n    r.push(\"\");\n    return this.header(\"# \") + r.join(\"\\n\");\n  }\n\n  public writeksolve(name: string = \"PuzzleGeometryPuzzle\"): string {\n    const od = this.getOrbitsDef(false);\n    return (\n      this.header(\"# \") + od.toKsolve(name, this.notationMapper).join(\"\\n\")\n    );\n  }\n\n  public getKPuzzleDefinition(\n    fortwisty: boolean = true,\n    includemoves: boolean = true,\n  ): KPuzzleDefinition {\n    const od = this.getOrbitsDef(fortwisty, includemoves);\n    const internalDefinition = od.toKPuzzleDefinition(includemoves);\n    (internalDefinition as any).experimentalPuzzleDescription =\n      this.puzzleDescription;\n    if (!internalDefinition) {\n      throw new Error(\"Missing definition!\");\n    }\n    return internalDefinition;\n  }\n\n  public getMoveFromBits(\n    moverange: number[],\n    amount: number,\n    inverted: boolean,\n    axiscmoves: number[][],\n    setmoves: number[] | undefined,\n    movesetorder: number,\n  ): PGTransform {\n    const moveorbits: PGOrbit[] = [];\n    const perms = [];\n    const oris = [];\n    for (const len of this.cubieords) {\n      perms.push(iota(len));\n      oris.push(zeros(len));\n    }\n    for (let m = moverange[0]; m <= moverange[1]; m++) {\n      const slicecmoves = axiscmoves[m];\n      for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n        const mperm = slicecmoves.slice(j, j + 2 * movesetorder);\n        const setnum = this.cubiesetnums[mperm[0]];\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          mperm[ii] = this.cubieordnums[mperm[ii]];\n        }\n        let inc = 2;\n        let oinc = 3;\n        if (inverted) {\n          inc = mperm.length - 2;\n          oinc = mperm.length - 1;\n        }\n        if (perms[setnum] === iota(this.cubieords[setnum])) {\n          perms[setnum] = perms[setnum].slice();\n          if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {\n            oris[setnum] = oris[setnum].slice();\n          }\n        }\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          perms[setnum][mperm[(ii + inc) % mperm.length]] = mperm[ii];\n          if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {\n            oris[setnum][mperm[ii]] =\n              (mperm[(ii + oinc) % mperm.length] -\n                mperm[(ii + 1) % mperm.length] +\n                2 * this.orbitoris[setnum]) %\n              this.orbitoris[setnum];\n          }\n        }\n      }\n    }\n    let lastId = new PGOrbit(iota(24), zeros(24), 1);\n    for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n      if (setmoves && !setmoves[ii]) {\n        continue;\n      }\n      if (this.orbitoris[ii] === 1 || this.options.fixedOrientation) {\n        if (perms[ii] === iota(lastId.perm.length)) {\n          if (perms[ii] !== lastId.perm) {\n            lastId = new PGOrbit(perms[ii], oris[ii], 1);\n          }\n          moveorbits.push(lastId);\n        } else {\n          moveorbits.push(new PGOrbit(perms[ii], oris[ii], 1));\n        }\n      } else {\n        const no = new Array<number>(oris[ii].length);\n        // convert ksolve oris to our internal ori rep\n        for (let jj = 0; jj < perms[ii].length; jj++) {\n          no[jj] = oris[ii][perms[ii][jj]];\n        }\n        moveorbits.push(new PGOrbit(perms[ii], no, this.orbitoris[ii]));\n      }\n    }\n    let mv = new PGTransform(moveorbits);\n    if (amount !== 1) {\n      mv = mv.mulScalar(amount);\n    }\n    return mv;\n  }\n\n  private omitSet(name: string): boolean {\n    for (const excludedSet of this.options.excludeOrbits) {\n      if (excludedSet === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private diffmvsets(a: any[], b: any[], slices: number, neg: boolean) {\n    for (let i = 0; i < a.length; i += 2) {\n      let found = false;\n      for (let j = 0; !found && j < b.length; j += 2) {\n        if (neg) {\n          if (\n            a[i][0] + b[j][1] === slices &&\n            a[i][1] + b[j][0] === slices &&\n            a[i + 1] === b[j + 1]\n          ) {\n            found = true;\n          }\n        } else {\n          if (\n            a[i][0] === b[j][0] &&\n            a[i][1] === b[j][1] &&\n            a[i + 1] === b[j + 1]\n          ) {\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // TODO: This is only public for testing; can we make it private again?\n  public getOrbitsDef(\n    fortwisty: boolean,\n    includemoves: boolean = true,\n  ): PGOrbitsDef {\n    // generate a representation of the puzzle\n    const setmoves = [];\n    if (fortwisty) {\n      for (let i = 0; i < this.cubiesetnames.length; i++) {\n        setmoves.push(1);\n      }\n    }\n    const setnames: string[] = [];\n    const setdefs: PGOrbitDef[] = [];\n    // if both a movelist and rotations are needed, don't add rotations\n    // that do not preserve the movelist.\n    const mps = [];\n    const addrot = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = this.getmovesets(k);\n      mps.push(moveset);\n      if (this.options.addRotations) {\n        addrot.push(1);\n      } else {\n        addrot.push(0);\n      }\n    }\n    const hasrotation = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const slices = this.moveplanesets[k].length;\n      // if the move set includes a rotation around this axis, don't add any more\n      let sawone = false;\n      const moveset = mps[k];\n      for (let i = 0; i < moveset.length; i += 2) {\n        if (moveset[i][0] === 0 && moveset[i][1] === slices) {\n          sawone = true;\n        }\n      }\n      hasrotation[k] = sawone;\n    }\n    if (\n      this.options.addRotations &&\n      (this.options.moveList || this.options.fixedPieceType !== null)\n    ) {\n      for (let i = 0; i < this.moverotations.length; i++) {\n        addrot[i] = 0;\n      }\n      for (let k = 0; k < this.moveplanesets.length; k++) {\n        // if the move set includes a rotation around this axis, don't add any more\n        if (hasrotation[k]) {\n          addrot[k] = 3;\n          continue;\n        }\n        // does a rotation around k preserve the move set?\n        for (let i = 0; i < this.moverotations.length; i++) {\n          let nn = this.moveplanenormals[k];\n          for (let ii = 1; ii * 2 <= this.movesetorders[i]; ii++) {\n            nn = nn.rotatepoint(this.moverotations[i][0]);\n            if (addrot[i] & ii) {\n              continue;\n            }\n            let found = -1;\n            let neg = false;\n            for (let j = 0; j < this.moveplanenormals.length; j++) {\n              if (nn.dist(this.moveplanenormals[j]) < eps) {\n                found = j;\n                break;\n              } else if (nn.dist(this.moveplanenormals[j].smul(-1)) < eps) {\n                found = j;\n                neg = true;\n                break;\n              }\n            }\n            if (found < 0) {\n              throw new Error(\"Could not find rotation\");\n            }\n            const cmp = mps[found];\n            if (\n              cmp.length !== mps[k].length ||\n              this.moveplanesets[k].length !==\n                this.moveplanesets[found].length ||\n              this.diffmvsets(\n                cmp,\n                mps[k],\n                this.moveplanesets[found].length,\n                neg,\n              )\n            ) {\n              addrot[i] |= ii;\n            }\n          }\n        }\n      }\n      for (let i = 0; i < this.moverotations.length; i++) {\n        if (addrot[i] === 0) {\n          addrot[i] = 1;\n        } else if (addrot[i] === 1) {\n          if (this.movesetorders[i] > 3) {\n            addrot[i] = 2;\n          } else {\n            addrot[i] = 0;\n          }\n        } else if (addrot[i] === 3) {\n          addrot[i] = 0;\n        } else {\n          throw new Error(\"Impossible addrot val\");\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      if (addrot[k] !== 0 && !hasrotation[k]) {\n        mps[k].push([0, this.moveplanesets[k].length]);\n        mps[k].push(addrot[k]);\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = mps[k];\n      const movesetorder = this.movesetorders[k];\n      // check there's no redundancy in moveset.\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = 0; j < i; j += 2) {\n          if (\n            moveset[i][0] === moveset[j][0] &&\n            moveset[i][1] === moveset[j][1]\n          ) {\n            throw new Error(\"Redundant moves in moveset.\");\n          }\n        }\n      }\n      const allbits = [];\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = moveset[i][0]; j <= moveset[i][1]; j++) {\n          allbits[j] = 1;\n        }\n      }\n      const axiscmoves = this.cmovesbyslice[k];\n      for (let i = 0; i < axiscmoves.length; i++) {\n        if (allbits[i] !== 1) {\n          continue;\n        }\n        const slicecmoves = axiscmoves[i];\n        for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n          if (this.skipcubie(slicecmoves[j])) {\n            continue;\n          }\n          const ind = this.cubiesetnums[slicecmoves[j]];\n          setmoves[ind] = 1;\n        }\n      }\n    }\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubiesetnames[i])) {\n        setmoves[i] = 0;\n        continue;\n      }\n      setnames.push(this.cubiesetnames[i]);\n      setdefs.push(\n        new PGOrbitDef(\n          this.cubieords[i],\n          this.options.fixedOrientation ? 1 : this.orbitoris[i],\n        ),\n      );\n    }\n    const solved: PGOrbit[] = [];\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubiesetnames[i])) {\n        continue;\n      }\n      const p = [];\n      const o = [];\n      for (let j = 0; j < this.cubieords[i]; j++) {\n        if (fortwisty) {\n          p.push(j);\n        } else {\n          const cubie = this.cubiesetcubies[i][j];\n          p.push(this.cubievaluemap[cubie]);\n        }\n        o.push(0);\n      }\n      solved.push(\n        new PGOrbit(\n          p,\n          o,\n          this.options.fixedOrientation ? 1 : this.orbitoris[i],\n        ),\n      );\n    }\n    const movenames: string[] = [];\n    const forcenames: boolean[] = [];\n    const moves: PGTransform[] = [];\n    const isrots: boolean[] = [];\n    if (includemoves) {\n      for (let k = 0; k < this.moveplanesets.length; k++) {\n        const moveplaneset = this.moveplanesets[k];\n        const slices = moveplaneset.length;\n        const moveset = mps[k];\n        const movesetgeo = this.movesetgeos[k];\n        for (let i = 0; i < moveset.length; i += 2) {\n          const movebits = moveset[i];\n          // did these movebits come from a specified move?\n          // if they did, we need to use that name.\n          let nameoverride: string | undefined;\n          let inverted = false;\n          if (this.parsedmovelist !== undefined) {\n            for (const parsedmove of this.parsedmovelist) {\n              if (parsedmove[1] !== k) {\n                continue;\n              }\n              let r = [];\n              if (parsedmove[4]) {\n                r = [parsedmove[2], parsedmove[3]];\n              } else {\n                r = [slices - parsedmove[3], slices - parsedmove[2]];\n              }\n              if (r[0] === movebits[0] && r[1] === movebits[1]) {\n                nameoverride = parsedmove[0];\n                inverted = !parsedmove[4];\n              }\n            }\n          }\n          if (nameoverride) {\n            movenames.push(nameoverride);\n            forcenames.push(true);\n          } else {\n            const mna = getmovename(movesetgeo, movebits, slices);\n            inverted = mna[1];\n            const movename = mna[0];\n            if (moveset[i + 1] === 1) {\n              movenames.push(movename);\n            } else {\n              movenames.push(movename + moveset[i + 1]);\n            }\n            forcenames.push(false);\n          }\n          isrots.push(movebits[0] === 0 && movebits[1] === slices);\n          const mv = this.getMoveFromBits(\n            movebits,\n            moveset[i + 1],\n            inverted,\n            this.cmovesbyslice[k],\n            setmoves,\n            this.movesetorders[k],\n          );\n          moves.push(mv);\n        }\n      }\n    }\n    let r = new PGOrbitsDef(\n      setnames,\n      setdefs,\n      new VisibleState(solved),\n      movenames,\n      moves,\n      isrots,\n      forcenames,\n    );\n    if (this.options.optimizeOrbits) {\n      r = r.optimize();\n    }\n    if (this.options.scrambleAmount !== 0) {\n      r.scramble(this.options.scrambleAmount);\n    }\n    return r;\n  }\n\n  public getScramble(n: number = 0): KTransformationData {\n    const od = this.getOrbitsDef(false);\n    return od.transformToKTransformationData(od.getScrambleTransformation(n));\n  }\n\n  public getMovesAsPerms(): Perm[] {\n    return this.getOrbitsDef(false).moveops.map((_) => _.toPerm());\n  }\n\n  public showcanon(disp: (s: string) => void): void {\n    // show information for canonical move derivation\n    showcanon(this.getOrbitsDef(false), disp);\n  }\n\n  public getsolved(): Perm {\n    // get a solved position\n    const r = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      for (let j = 0; j < this.stickersperface; j++) {\n        r.push(i);\n      }\n    }\n    return new Perm(r);\n  }\n\n  // Given a rotation description that says to align feature1\n  // with a given vector, and then as much as possible feature2\n  // with another given vector, return a Quaternion that\n  // performs this rotation.\n  private getOrientationRotation(desiredRotation: any[]): Quat {\n    const [feature1name, [x1, y1, z1]] = desiredRotation[0];\n    const direction1 = new Quat(0, x1, -y1, z1);\n\n    const [feature2name, [x2, y2, z2]] = desiredRotation[1];\n    const direction2 = new Quat(0, x2, -y2, z2);\n    let feature1: Quat | null = null;\n    let feature2: Quat | null = null;\n    const feature1geoname = this.swizzler.unswizzle(feature1name);\n    const feature2geoname = this.swizzler.unswizzle(feature2name);\n    for (const gn of this.geonormals) {\n      if (feature1geoname === gn[1]) {\n        feature1 = gn[0];\n      }\n      if (feature2geoname === gn[1]) {\n        feature2 = gn[0];\n      }\n    }\n    if (!feature1) {\n      throw new Error(`Could not find feature ${feature1name}`);\n    }\n    if (!feature2) {\n      throw new Error(`Could not find feature ${feature2name}`);\n    }\n    const r1 = feature1.pointrotation(direction1);\n    const feature2rot = feature2.rotatepoint(r1);\n    const r2 = feature2rot\n      .unproject(direction1)\n      .pointrotation(direction2.unproject(direction1));\n    return r2.mul(r1);\n  }\n\n  private getInitial3DRotation(): Quat {\n    const basefacecount = this.baseFaceCount;\n    let orientationDescription: FaceBasedOrientationDescription | null = null;\n    if (this.options.puzzleOrientation) {\n      orientationDescription = this.options.puzzleOrientation;\n    } else if (this.options.puzzleOrientations) {\n      orientationDescription = this.options.puzzleOrientations[basefacecount];\n    }\n    // either no option specified or no matching key in\n    // puzzleOrientations.\n    if (!orientationDescription) {\n      orientationDescription = defaultOrientations()[basefacecount];\n    }\n    if (!orientationDescription) {\n      throw new Error(\"No default orientation?\");\n    }\n    return this.getOrientationRotation(orientationDescription);\n  }\n\n  private generate2dmapping(\n    w: number = 800,\n    h: number = 500,\n    trim: number = 10,\n    threed: boolean = false,\n    twodshrink: number = 0.92,\n  ): (fn: number, q: Quat) => number[] {\n    // generate a mapping to use for 2D for textures, svg\n    w -= 2 * trim;\n    h -= 2 * trim;\n    function extendedges(a: number[][], n: number): void {\n      let dx = a[1][0] - a[0][0];\n      let dy = a[1][1] - a[0][1];\n      const ang = (2 * Math.PI) / n;\n      const cosa = Math.cos(ang);\n      const sina = Math.sin(ang);\n      for (let i = 2; i < n; i++) {\n        const ndx = dx * cosa + dy * sina;\n        dy = dy * cosa - dx * sina;\n        dx = ndx;\n        a.push([a[i - 1][0] + dx, a[i - 1][1] + dy]);\n      }\n    }\n    // Find a net from a given face count.  Walk it, assuming we locate\n    // the first edge from (0,0) to (1,1) and compute the minimum and\n    // maximum vertex locations from this.  Then do a second walk, and\n    // assign the actual geometry.\n    this.genperms();\n    const boundarygeo = this.getboundarygeometry();\n    const face0 = boundarygeo.facenames[0][0];\n    const polyn = face0.length; // number of vertices; 3, 4, or 5\n    const net = this.net;\n    if (net === null) {\n      throw new Error(\"No net?\");\n    }\n    const edges: any = {};\n    let minx = 0;\n    let miny = 0;\n    let maxx = 1;\n    let maxy = 0;\n    edges[net[0][0]] = [\n      [1, 0],\n      [0, 0],\n    ];\n    extendedges(edges[net[0][0]], polyn);\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges[f1]) {\n          continue;\n        }\n        edges[f1] = [edges[f0][j % polyn], edges[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges[f1], polyn);\n      }\n    }\n    for (const f in edges) {\n      const es = edges[f];\n      for (const esi of es) {\n        minx = Math.min(minx, esi[0]);\n        maxx = Math.max(maxx, esi[0]);\n        miny = Math.min(miny, esi[1]);\n        maxy = Math.max(maxy, esi[1]);\n      }\n    }\n    const sc = Math.min(w / (maxx - minx), h / (maxy - miny));\n    const xoff = 0.5 * (w - sc * (maxx + minx));\n    const yoff = 0.5 * (h - sc * (maxy + miny));\n    const geos: Record<string, Quat[]> = {};\n    const bg = this.getboundarygeometry();\n    const edges2: any = {};\n    const initv = [\n      [sc + xoff, yoff],\n      [xoff, yoff],\n    ];\n    edges2[net[0][0]] = initv;\n    extendedges(edges2[net[0][0]], polyn);\n    geos[this.facenames[0][1]] = this.project2d(0, 0, [\n      new Quat(0, initv[0][0], initv[0][1], 0),\n      new Quat(0, initv[1][0], initv[1][1], 0),\n    ]);\n    const connectat = [];\n    connectat[0] = 0;\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges2[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      let gfi = -1;\n      for (let j = 0; j < bg.facenames.length; j++) {\n        if (f0 === bg.facenames[j][1]) {\n          gfi = j;\n          break;\n        }\n      }\n      if (gfi < 0) {\n        throw new Error(`Could not find first face name ${f0}`);\n      }\n      const thisface = bg.facenames[gfi][0];\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges2[f1]) {\n          continue;\n        }\n        edges2[f1] = [\n          edges2[f0][j % polyn],\n          edges2[f0][(j + polyn - 1) % polyn],\n        ];\n        extendedges(edges2[f1], polyn);\n        // what edge are we at?\n        const caf0 = connectat[gfi];\n        const mp = thisface[(caf0 + j) % polyn]\n          .sum(thisface[(caf0 + j + polyn - 1) % polyn])\n          .smul(0.5);\n        const epi = findelement(bg.edgenames, mp);\n        const edgename = bg.edgenames[epi][1];\n        const el = splitByFaceNames(edgename, this.facenames);\n        const gf1 = el[f0 === el[0] ? 1 : 0];\n        let gf1i = -1;\n        for (let k = 0; k < bg.facenames.length; k++) {\n          if (gf1 === bg.facenames[k][1]) {\n            gf1i = k;\n            break;\n          }\n        }\n        if (gf1i < 0) {\n          throw new Error(\"Could not find second face name\");\n        }\n        const otherface = bg.facenames[gf1i][0];\n        for (let k = 0; k < otherface.length; k++) {\n          const mp2 = otherface[k].sum(otherface[(k + 1) % polyn]).smul(0.5);\n          if (mp2.dist(mp) <= eps) {\n            const p1 = edges2[f0][(j + polyn - 1) % polyn];\n            const p2 = edges2[f0][j % polyn];\n            connectat[gf1i] = k;\n            geos[gf1] = this.project2d(gf1i, k, [\n              new Quat(0, p2[0], p2[1], 0),\n              new Quat(0, p1[0], p1[1], 0),\n            ]);\n            break;\n          }\n        }\n      }\n    }\n    let hix = 0;\n    let hiy = 0;\n    const rot = this.getInitial3DRotation();\n    for (let face of this.faces) {\n      if (threed) {\n        face = face.rotate(rot);\n      }\n      for (let j = 0; j < face.length; j++) {\n        hix = Math.max(hix, Math.abs(face.get(j).b));\n        hiy = Math.max(hiy, Math.abs(face.get(j).c));\n      }\n    }\n    const sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4);\n    const mappt2d = (fn: number, q: Quat): number[] => {\n      if (threed) {\n        q = q.rotatepoint(rot);\n        const xoff2 = 0.5 * trim + 0.25 * w;\n        const xmul = this.baseplanes[fn].rotateplane(rot).d < 0 ? 1 : -1;\n        return [\n          trim + w * 0.5 + xmul * (xoff2 - q.b * sc2),\n          trim + h * 0.5 + q.c * sc2,\n        ];\n      } else {\n        const g = geos[this.facenames[fn][1]];\n        return [\n          trim + twodshrink * q.dot(g[0]) + g[2].b,\n          trim + h - twodshrink * q.dot(g[1]) - g[2].c,\n        ];\n      }\n    };\n    return mappt2d;\n  }\n\n  public generatesvg(\n    w: number = 800,\n    h: number = 500,\n    trim: number = 10,\n    threed: boolean = false,\n  ): string {\n    const mappt2d = this.generate2dmapping(w, h, trim, threed);\n    function drawedges(id: string, pts: number[][], color: string): string {\n      return `<polygon id=\"${id}\" class=\"sticker\" style=\"fill: ${color}\" points=\"${pts\n        .map((p) => `${p[0]} ${p[1]}`)\n        .join(\" \")}\"/>\\n`;\n    }\n    // Let's build arrays for faster rendering.  We want to map from geo\n    // base face number to color, and we want to map from geo face number\n    // to 2D geometry.  These can be reused as long as the puzzle overall\n    // orientation and canvas size remains unchanged.\n    const pos = this.getsolved();\n    const colormap = [];\n    const facegeo = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      colormap[i] = this.colors[this.facenames[i][1]];\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const facenum = Math.floor(i / this.stickersperface);\n      const fg = [];\n      for (let j = 0; j < face.length; j++) {\n        fg.push(mappt2d(facenum, face.get(j)));\n      }\n      facegeo.push(fg);\n    }\n    const svg = [];\n    // group each base face so we can add a hover element\n    for (let j = 0; j < this.baseFaceCount; j++) {\n      svg.push(\"<g>\");\n      svg.push(`<title>${this.facenames[j][1]}</title>\\n`);\n      for (let ii = 0; ii < this.stickersperface; ii++) {\n        const i = j * this.stickersperface + ii;\n        const cubie = this.facetocubie[i];\n        const cubieori = this.facetoord[i];\n        const cubiesetnum = this.cubiesetnums[cubie];\n        const cubieord = this.cubieordnums[cubie];\n        const color = this.graybyori(cubie) ? \"#808080\" : colormap[pos.p[i]];\n        let id = `${this.cubiesetnames[cubiesetnum]}-l${cubieord}-o${cubieori}`;\n        svg.push(drawedges(id, facegeo[i], color));\n        if (this.duplicatedFaces[i]) {\n          for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n            id = `${this.cubiesetnames[cubiesetnum]}-l${cubieord}-o${jj}`;\n            svg.push(drawedges(id, facegeo[i], color));\n          }\n        }\n      }\n      svg.push(\"</g>\");\n    }\n    const html = `<svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 800 500\">\\n<style type=\"text/css\"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>\\n${svg.join(\n      \"\",\n    )}</svg>`;\n    return html;\n  }\n\n  // The colorfrac parameter says how much of the face should be\n  // colored (vs dividing lines); we default to 0.77 which seems\n  // to work pretty well.  It should be a number between probably\n  // 0.4 and 0.9.\n  public get3d(options?: {\n    stickerColors?: string[];\n    darkIgnoredOrbits?: boolean;\n  }): StickerDat {\n    const stickers = [];\n    const rot = this.getInitial3DRotation();\n    const faces = [];\n    const maxdist: number = 0.52 * this.basefaces[0].get(0).len();\n    for (let i = 0; i < this.basefaces.length; i++) {\n      const coords = this.basefaces[i].rotate(rot);\n      const name = this.facenames[i][1];\n      faces.push({ coords: toFaceCoords(coords, maxdist), name });\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const facenum = Math.floor(i / this.stickersperface);\n      const cubie = this.facetocubie[i];\n      const cubieori = this.facetoord[i];\n      const cubiesetnum = this.cubiesetnums[cubie];\n      const cubieord = this.cubieordnums[cubie];\n      let color = this.graybyori(cubie)\n        ? options?.darkIgnoredOrbits\n          ? \"#222222\"\n          : \"#808080\"\n        : this.colors[this.facenames[facenum][1]];\n      if (options?.stickerColors) {\n        color = options.stickerColors[i];\n      }\n      const coords = this.faces[i].rotate(rot);\n      stickers.push({\n        coords: toFaceCoords(coords, maxdist),\n        color,\n        orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord,\n        ori: cubieori,\n        face: facenum,\n      });\n      let fcoords = coords;\n      if (this.duplicatedFaces[i]) {\n        const rotdist = fcoords.length / this.duplicatedFaces[i];\n        for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n          for (let k = 0; k < rotdist; k++) {\n            fcoords = fcoords.rotateforward();\n          }\n          stickers.push({\n            coords: toFaceCoords(fcoords, maxdist),\n            color,\n            orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord,\n            ori: jj,\n            face: facenum,\n            isDup: true,\n          });\n        }\n      }\n    }\n    const grips: StickerDatAxis[] = [];\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      const order = this.movesetorders[i];\n      for (const gn of this.geonormals) {\n        if (msg[0] === gn[1] && msg[1] === gn[2]) {\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot), 1),\n            quantumMove: new Move(msg[0]),\n            order,\n          });\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot).smul(-1), 1),\n            quantumMove: new Move(msg[2]),\n            order,\n          });\n        }\n      }\n    }\n    const twodmapper = this.generate2dmapping(2880, 2160, 0, false, 1.0);\n    const g = (function () {\n      const irot = rot.invrot();\n      return function (facenum: number, coords: number[]): number[] {\n        let q = new Quat(\n          0,\n          coords[0] * maxdist,\n          -coords[1] * maxdist,\n          coords[2] * maxdist,\n        );\n        q = q.rotatepoint(irot);\n        const x = twodmapper(facenum, q);\n        x[0] /= 2880;\n        x[1] = 1 - x[1] / 2160;\n        return x;\n      };\n    })().bind(this);\n    return {\n      stickers,\n      faces,\n      axis: grips,\n      unswizzle: this.unswizzle.bind(this),\n      notationMapper: this.notationMapper,\n      textureMapper: { getuv: g },\n    };\n  }\n\n  //  From the name of a geometric element (face, vertex, edge), get a\n  //  normal vector respecting the default orientation.  This is useful\n  //  to define the initial position of the camera in a 3D scene.  The\n  //  return value is normalized, so multiply it by the camera distance.\n  //  Returns undefined if no such geometric element.\n  public getGeoNormal(geoname: string): number[] | undefined {\n    const rot = this.getInitial3DRotation();\n    const grip = this.swizzler.unswizzle(geoname);\n    for (const gn of this.geonormals) {\n      if (grip === gn[1]) {\n        const r = toCoords(gn[0].rotatepoint(rot), 1);\n        //  This routine is intended to use for the camera location.\n        //  If the camera location is vertical, and we give some\n        //  near-zero values for x and z, then the rotation in the\n        //  X/Z plane will be somewhat arbitrary.  So we clean up the\n        //  returned vector here.  We give a very slight positive\n        //  z value.\n        if (Math.abs(r[0]) < eps && Math.abs(r[2]) < eps) {\n          r[0] = 0.0;\n          r[2] = 1e-6;\n        }\n        return r;\n      }\n    }\n    return undefined;\n  }\n\n  private getfaceindex(facenum: number): number {\n    const divid = this.stickersperface;\n    return Math.floor(facenum / divid);\n  }\n\n  public textForTwizzleExplorer(): string {\n    return `Faces ${this.baseplanerot.length}\nStickers per face ${this.stickersperface}\nShort edge ${this.shortedge}\nCubies ${this.cubies.length}\nEdge distance ${this.edgedistance}\nVertex distance ${this.vertexdistance}`;\n  }\n\n  writeSchreierSims(tw: (s: string) => void) {\n    const os = this.getOrbitsDef(false);\n    const as = os.reassemblySize();\n    tw(`Reassembly size is ${as}`);\n    const ss = schreierSims(this.getMovesAsPerms(), tw);\n    const r = as / ss;\n    tw(`Ratio is ${r}`);\n  }\n}\n\nexport class PGNotation {\n  private orbitNames: string[];\n  constructor(private pg: PuzzleGeometry, od: PGOrbitsDef) {\n    this.orbitNames = od.orbitnames;\n  }\n\n  public lookupMove(move: Move): KTransformationData | null {\n    const mv = this.pg.parseMove(move);\n    // if a move list subset is defined, don't return moves outside the subset.\n    if (this.pg.parsedmovelist) {\n      let found = false;\n      for (const parsedmove of this.pg.parsedmovelist) {\n        if (\n          parsedmove[1] === mv[1] &&\n          parsedmove[2] === mv[2] &&\n          parsedmove[3] === mv[3] &&\n          parsedmove[4] === mv[4]\n        ) {\n          found = true;\n        }\n      }\n      if (!found) {\n        return null;\n      }\n    }\n    let bits = [mv[2], mv[3]];\n    if (!mv[4]) {\n      const slices = this.pg.moveplanesets[mv[1]].length;\n      bits = [slices - mv[3], slices - mv[2]];\n    }\n    const pgmv = this.pg.getMoveFromBits(\n      bits,\n      mv[5],\n      !mv[4],\n      this.pg.cmovesbyslice[mv[1]],\n      undefined,\n      this.pg.movesetorders[mv[1]],\n    );\n    const r = PGOrbitsDef.transformToKTransformationData(this.orbitNames, pgmv);\n    return r;\n  }\n}\n"],"names":["FaceNameSwizzler","facenames","gripnames_arg","_classCallCheck","prefixFree","gripnames","this","i","length","j","startsWith","_createClass","key","value","names","s","r","at","currentMatch","substr","Error","concat","push","list","sep","join","userinput","longname","e1","splitByFaceNames","e2","found","e","endsWith","spinmatch","slice","upperCaseGrip","toUpperCase","g","NullMapper","move","FTONotationMapper","child","sw","family","innerLayer","outerLayer","Move","QuantumMove","amount","notationToInternal","fam","substring","notationToExternal","FaceRenamingMapper","internalNames","externalNames","grip","a","b","suffix","upper","isLowerCase","joinByFaceIndices","toLowerCase","ngrip","convertString","convert","MegaminxScramblingNotationMapper","Math","abs","NxNxNCubeMapper","slices","pyraminxFamilyMap","U","L","R","B","u","l","Uv","Lv","Rv","Bv","D","F","BL","BR","tetraminxFamilyMap","d","f","bl","br","pyraminxFamilyMapWCA","pyraminxExternalQuantumY","pyraminxInternalQuantumY","PyraminxNotationMapper","wcaHack","map","newFamilyWCA","newFamily","isIdentical","quantum","_i","_Object$entries","Object","entries","_Object$entries$_i","_slicedToArray","external","internal","_i2","_Object$entries2","_Object$entries2$_i","TetraminxNotationMapper","_PyraminxNotationMapp","_inherits","_super","_createSuper","_this","call","skewbFamilyMap","UL","UR","ULv","Fv","URv","Dv","skewbExternalQuantumX","skewbInternalQuantumX","skewbInternalQuantumXPrime","skewbExternalQuantumY","skewbInternalQuantumY","skewbInternalQuantumYPrime","skewbExternalQuantumZ","skewbInternalQuantumZ","skewbInternalQuantumZPrime","SkewbNotationMapper","_i3","_Object$entries3","_Object$entries3$_i","spinmatchv","parseOptions","argv","argp","options","option","addRotations","allMoves","outerBlockMoves","vertexMoves","includeCornerOrbits","includeEdgeOrbits","fixedOrientation","includeCenterOrbits","excludeOrbits","split","moveList","optimizeOrbits","scrambleAmount","fixedPieceType","orientCenters","puzzleOrientation","JSON","parse","puzzleDescription","parsePuzzleDescription","PuzzleGeometryFullOptions","arguments","undefined","verbosity","grayCorners","grayCenters","grayEdges","puzzleOrientations","assign","zeroCache","iotaCache","zeros","n","c","Array","iota","lcm","t","m","gcd","Perm","p","p2","cyc","seen","incyc","cs","PGOrbitDef","size","mod","BigInt","factorial","pow","lastGlobalDefinitionCounter","externalName","mapper","moveString","mv","mv2","toString","PGOrbitsDef","orbitnames","orbitdefs","solved","movenames","moveops","isRotation","forcenames","mp","orbits","toKPuzzle","mvname","pd","perm","ori","name","result","describeSet","appendDefinition","name2","doinv","inv","includemoves","start","numPieces","numOrientations","startTransformation","pieces","permutation","orientation","moves","transformToKTransformationData","startStateData","neworbitnames","neworbitdefs","newsolved","newmoveops","om","du","DisjointUnion","changed","k","union","keepori","duo","o","find","nontriv","multiple","h","no","on","nv","remapVS","remap","killOri","VisibleState","_","PGTransform","mul","getScrambleTransformation","pool","floor","random","ri","rj","rm","reassemblySize","_PGOrbit","orimod","newPerm","newOri","done","v","toPerm","order","nextNew","reassign","ov","useVS","concise","isIdentity","zeroOris","newori","kcache","PGOrbit","PGTransformBase","newOrbits","_step","_iterator","_createForOfIteratorHelper","orbit","err","equal","_step2","_iterator2","_step3","perms","_iterator3","_i12","_perms","_step4","_iterator4","_loop","identicalPieces","_step5","_iterator5","_PGTransformBase","_super2","internalMul","internalInv","_PGTransformBase2","_super3","heads","ah","bh","PGPuzzles","skewb","helicopter","dino","pyramorphix","mastermorphix","pyraminx","tetraminx","megaminx","gigaminx","teraminx","petaminx","examinx","zetaminx","yottaminx","pentultimate","starminx","chopasaurus","FTO","octastar","icosamate","eps","centermassface","face","Quat","sum","smul","solvethreeplanes","p1","p3","planes","intersect3","dt","q","hypot","sqrt","dot","normalize","acos","a00","a01","a02","a10","a11","a12","a20","a21","a22","invrot","ab","ac","ad","cross","sub","len","orthogonal","_this2","rotatepoint","det","det3x3","x","_this3","side","inout","nface","kk","vk","r2","pt","faces","nfaces","cutface","dist","eps2","uniqueplanes","planerot","rotateplane","wasseen","getface","FactoredNumber","mult","schreierSims","disp","identity","sgs","sgsi","sgslen","Tk","Tklen","knutha","knuthb","resolve","none","sz","tks","sollen","avgs","mults","cnt","lensum","multiply","avg","getsgs","Face","coords","off","sx","sy","get","FaceTree","left","right","_this$left","_this$right","arr","leftfirst","_this$left2","_this$right2","collect","_this$right3","_this$left3","eps3","orientationDefaults","findelement","getPG3DNamedPuzzles","getPuzzleDescriptionString","puzzleName","PUZZLE_BASE_SHAPES","PUZZLE_CUT_TYPES","filter","Boolean","shape","cuts","cutType","distance","parseFloat","getPuzzleGeometryByDesc","desc","parsed","pg","PuzzleGeometry","allstickers","genperms","getPuzzleGeometryByName","getmovename","geo","bits","inverted","movenameFamily","movenamePrefix","String","_step8","_iterator8","facename","toCoords","maxdist","toFaceCoords","cmovesbyslice","duplicatedFaces","duplicatedCubies","fixedCubie","net","colors","notationMapper","addNotationMapper","setReidOrder","console","log","header","create","moveplanes","moveplanes2","cubies","s5","cube","octahedron","dx","dy","dd","ang","PI","cos","sin","icosahedron","d36","dodecahedron","rotations","ns","negns","closure","baseplane","baseplanerot","baseplanes","baseFaceCount","BB","FF","FR","FL","DR","DL","DD","C","E","A","G","I","S","H","J","K","M","O","P","N","Q","baseface","zero","facenormal","makenormal","edgenormal","vertexnormal","boundary","firstface","edgedistance","vertexdistance","_step9","cutplanes","intersects","sawface","sawedge","sawvertex","_iterator9","cut","normal","makecut","basefaces","_step10","_iterator10","rotateface","faceplanes","vertexnames","edgenames","edgesperface","searchaddelement","_step11","_iterator11","el","jj","otherfaces","facelist","facenametoindex","faceindextoname","_step12","_iterator12","neti","fi","ii","fn2","of","faceplane","midpoint","jjj","midpoint2","swizzler","oridata","markedface","_step13","oriprefs","_iterator13","_step14","fn","_iterator14","_step15","_iterator15","_step16","_iterator16","_step17","_iterator17","f1","f2","c1","c2","st","geonormals","_i23","_faceplanes","_i24","_edgenames","edgename","_i25","_vertexnames","vertexname","geonormalnames","setGripNames","_step18","_iterator18","_step19","rotation","_iterator19","moveplane","sameplane","ft","tar","rval","stickersperface","_step20","simplerot","cm","_iterator20","finished","sortme","cm2","centermass","sort","_step21","_iterator21","rot","rotate","shortedge","_step22","_iterator22","keyface2","_step23","sfcc","fromCharCode","_iterator23","moveplanesets","moveplaneset","dv","_step24","_iterator24","facelisthash","face2","facecentermass","facen","edgen","targvec","edgen2","plane","x0","olen","y0","delta","cosr","sinr","x1","y1","_this4","rots","_step6","_iterator6","_step7","_iterator7","expandfaces","_step25","moveplanenormals","_iterator25","_step34","qnormal","_iterator34","moveplanenormal","_step26","_iterator26","normalizeplane","goodnormal","sizes","moverotations","_step27","_iterator27","angle","reverse","sizes2","movesetorders","movesetgeos","gtype","_step28","p0","neg","pos","_iterator28","geonormal","Map","keyface","suff","s2","set","_step29","facetocubie","facetoord","_iterator29","values","cmall","looplimit","_step35","_iterator35","mini","ofacelist","typenames","cubiesetnames","cubietypecounts","orbitoris","cubiesetnum","cubiesetnums","cubieordnums","cubieords","cubievaluemap","getcolorkey","cubienum","getfaceindex","cubiesetcubies","cubie","cubiekeymap","cubievalueid","facecnt","typectr","typename","queue","qg","cind","cubiecolorkey","_step30","_iterator30","moverotation","tq","findface","reidmap","_i35","_reidorder","mask","charCodeAt","_step31","_iterator31","_step32","cubieset","_iterator32","_step33","_iterator33","newmv","modified","unswizzle","re","RegExp","match","loslice","hislice","parseInt","amountstr","bm","fullrotation","msi","geoname","firstgrip","parseMove","stringToBlockMove","center","towards","hiv","hii","hii2","qs","slicenum","slicecnts","bhi","axiscmoves","sc","cubiedone","ocm","fi2","face1","face0","_step36","_iterator36","_step37","parsedmovelist","_iterator37","parsemove","clear","_step38","_iterator38","parsedmove","msg","dep","keyface3","newr","skipbyori","comment","os","getOrbitsDef","mvs","movename","toGap","ip","__","od","toKsolve","fortwisty","internalDefinition","toKPuzzleDefinition","experimentalPuzzleDescription","moverange","setmoves","movesetorder","_step39","moveorbits","oris","_iterator39","slicecmoves","mperm","setnum","inc","oinc","lastId","mulScalar","_step40","_iterator40","setnames","setdefs","mps","addrot","moveset","getmovesets","hasrotation","sawone","nn","cmp","diffmvsets","allbits","skipcubie","ind","omitSet","isrots","movesetgeo","movebits","nameoverride","_step41","_iterator41","mna","getMoveFromBits","optimize","scramble","orders","commutes","permA","permB","curlev","nextlev","uniq","sti","nst","showcanon","desiredRotation","_step42","_desiredRotation$","feature1name","_desiredRotation$$","z1","direction1","_desiredRotation$2","feature2name","_desiredRotation$2$","x2","y2","z2","direction2","feature1","feature2","feature1geoname","feature2geoname","_iterator42","gn","r1","pointrotation","unproject","basefacecount","orientationDescription","getOrientationRotation","_this5","w","trim","threed","twodshrink","extendedges","cosa","sina","ndx","boundarygeo","getboundarygeometry","polyn","edges","minx","miny","maxx","maxy","_step43","_iterator43","f0","_step44","es","_iterator44","esi","min","max","xoff","yoff","geos","bg","edges2","initv","project2d","connectat","_step45","_iterator45","gfi","thisface","caf0","epi","gf1","gf1i","otherface","mp2","_step46","hix","hiy","getInitial3DRotation","_iterator46","sc2","mappt2d","xoff2","xmul","generate2dmapping","drawedges","id","pts","color","getsolved","colormap","facegeo","facenum","fg","svg","cubieori","cubieord","graybyori","html","stickers","darkIgnoredOrbits","stickerColors","ord","fcoords","rotdist","rotateforward","isDup","grips","_step47","_iterator47","coordinates","quantumMove","twodmapper","irot","bind","axis","textureMapper","getuv","_step48","_iterator48","divid","tw","as","ss","getMovesAsPerms","PGNotation","orbitNames","_step49","_iterator49","pgmv"],"sourceRoot":""}